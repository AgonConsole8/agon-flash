; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\main.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
	SEGMENT BSS
_errno:
	DS	3
.DEFINE "errno"
.ALIAS "_errno"
.CLASS 83
.VALUE _errno
.TYPE 4
.ENDEF
;    1	/*
;    2	 * Title:			Agon MOS firmware upgrade utility
;    3	 * Author:			Jeroen Venema
;    4	 * Created:			17/12/2022
;    5	 * Last Updated:	17/12/2022
;    6	 * 
;    7	 * Modinfo:
;    8	 * 17/12/2022:		Initial version
;    9	 * 18/12/2022:		MOS 1.00/1.01 one-off upgrade branch with fixed filename/CRC32 code, changed MOS API and while(1) loops
;   10	 */
;   11	
;   12	#include <ez80.h>
;   13	#include <stdio.h>
;   14	#include <stdlib.h>
;   15	#include <ERRNO.H>
;   16	#include "mos-interface.h"
;   17	#include "flash.h"
;   18	#include "agontimer.h"
;   19	#include "crc32.h"
;   20	
;   21	int errno; // needed by standard library
	SEGMENT CODE
;   22	enum states{firmware,recover,systemreset};
;   23	
;   24	#define FILENAME	"firmware103rc1.bin"
;   25	#define CRC103RC1	0xC7EB8372
;   26	
;   27	// separate putch function that doesn't rely on a running MOS firmware
;   28	// UART0 initialization done by MOS firmware previously
;   29	// This utility doesn't run without MOS to load it anyway
;   30	int putch(int c)
;   31	{
_putch:
.DEFINE "_putch"

.VALUE _putch

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "putch",31,"_putch"

.LINE 31

.DEFINE "c"

.CLASS 65

.VALUE 6

.TYPE 4

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
.ENDEF

;   32		UINT8 lsr,temt;
;   33		
;   34		while((UART0_LSR & 0x40) == 0);
L_1:
.LINE 34

	IN0	A,(197)
	AND	A,%40
	UEXT	HL
	LD	L,A
	CALL	__icmpzero
	JR	Z,L_1
;   35		UART0_THR = c;
.LINE 35

	LD	A,(IX+%6)
	OUT0	(192),A
;   36		return c;
.LINE 36

	LD	HL,(IX+%6)
;   37	}
.LINE 37

	LD	SP,IX
	POP	IX
	RET	


;**************************** _putch ***************************
;Name                         Addr/Register   Size   Type
;c                                     IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "putch",37,"_putch"
;   38	
;   39	int main(int argc, char * argv[]) {
_main:
.DEFINE "_main"

.VALUE _main

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "main",39,"_main"

.LINE 39

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

.DEFINE "counter"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "size"

.CLASS 65

.VALUE -6

.TYPE 14

.ENDEF

.DEFINE "response"

.CLASS 65

.VALUE -7

.TYPE 12

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -8

.TYPE 12

.ENDEF

.DEFINE "addressfrom"

.CLASS 65

.VALUE -11

.TYPE 14

.ENDEF

.DEFINE "state"

.CLASS 65

.VALUE -14

.TYPE 4

.ENDEF

.DEFINE "pagemax"

.CLASS 65

.VALUE -17

.TYPE 14

.ENDEF

.DEFINE "ptr"

.CLASS 65

.VALUE -20

.TYPE 34

.ENDEF

.DEFINE "addressto"

.CLASS 65

.VALUE -23

.TYPE 14

.ENDEF

.DEFINE "value"

.CLASS 65

.VALUE -24

.TYPE 12

.ENDEF

.DEFINE "crcresult"

.CLASS 65

.VALUE -28

.TYPE 15

.ENDEF

.DEFINE "lastpagebytes"

.CLASS 65

.VALUE -31

.TYPE 14

.ENDEF

.DEFINE "crcexpected"

.CLASS 65

.VALUE -38

.TYPE 15

.ENDEF

.DEFINE "crcbackup"

.CLASS 65

.VALUE -42

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFD3
	LD	SP,HL
;   40		UINT32 crcexpected,crcresult,crcbackup;
;   41		UINT24 size = 0;
.LINE 41

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
;   42		UINT8 file;
;   43		char* ptr = (char*)BUFFER1;
.LINE 43

	LD	BC,327680
	LD	(IX+%FFFFFFEC),BC
;   44		UINT8 response;
;   45		UINT8 value;
;   46		UINT24 counter,pagemax, lastpagebytes;
;   47		UINT24 addressto,addressfrom;
;   48		enum states state;
;   49		
;   50		printf("Agon MOS firmware upgrade utility\n\r");
.LINE 50

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__2
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   51		printf("This utility will upgrade an existing 1.00/1.01 firmware to 1.03rc1\r\n\r\n");
.LINE 51

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__3
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   52		
;   53		file = mos_fopen(FILENAME, fa_read);
.LINE 53

	LD	BC,1
	PUSH	BC
	LD	BC,L__4
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF8),A
;   54		if(!file)
.LINE 54

	OR	A,A
	JR	NZ,L_7
;   55		{
;   56			printf("Error opening \"%s\" - please push reset button",FILENAME);
.LINE 56

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__6
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__7
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__8
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   57			while(1);
L_5:
.LINE 57

	JR	L_5
;   58		}
L_7:
.LINE 58

;   59		
;   60		crcexpected = CRC103RC1;
.LINE 60

	LD	BC,15434610
	LD	A,%C7
	LD	(IX+%FFFFFFDA),BC
	LD	(IX+%FFFFFFDD),A
;   61	
;   62		printf("Loading file : %s\n\r",FILENAME);
.LINE 62

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__9
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__10
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__11
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   63		printf("File size    : %d byte(s)", size);
.LINE 63

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__12
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__13
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   64	
;   65		// Read file to memory
;   66		//mod = 0;
;   67		while(!mos_feof(file))
.LINE 67

	JR	L_11
L_12:
;   68		{
;   69			*ptr = mos_fgetc(file);
.LINE 69

	LD	C,(IX+%FFFFFFF8)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fgetc
	POP	BC
	LD	HL,(IX+%FFFFFFEC)
	LD	(HL),A
;   70			ptr++;
.LINE 70

	LD	BC,(IX+%FFFFFFEC)
	INC	BC
	LD	(IX+%FFFFFFEC),BC
;   71			size++;
.LINE 71

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;   72			//mod++;
;   73			//if(mod > 1024)
;   74			if(size%1024 == 0)
.LINE 74

	LD	BC,1023
	LD	HL,(IX+%FFFFFFFA)
	CALL	__iand
	CALL	__icmpzero
	JR	NZ,L_11
;   75			{
;   76				//mod = 0;
;   77				printf("\rFile size    : %d byte(s)", size);
.LINE 77

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__15
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%FFFFFFFA)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__16
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   78	
;   79			}
;   80		}		
L_11:
.LINE 80

	LD	C,(IX+%FFFFFFF8)
	LD	B,%0
	PUSH	BC
	CALL	_mos_feof
	POP	BC
	OR	A,A
	JR	Z,L_12
;   81		mos_fclose(file);	
.LINE 81

	LD	C,(IX+%FFFFFFF8)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;   82		printf("\rFile size    : %d byte(s)\n\r", size);
.LINE 82

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__18
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%FFFFFFFA)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__19
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   83	
;   84		printf("Testing CRC32: 0x%08lx\n\r",crcexpected);
.LINE 84

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__20
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%8
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	A,%78
	LD	(___print_fmt+4),A
	LD	BC,199
	PUSH	BC
	LD	BC,15434610
	PUSH	BC
	CALL	__u_ultoa
	POP	BC
	POP	BC
	LD	BC,L__21
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   85		crcresult = crc32((char*)BUFFER1, size);
.LINE 85

	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	LD	BC,327680
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE4),HL
	LD	(IX+%FFFFFFE7),E
;   86		printf("CRC32 result : 0x%08lx\n\r",crcresult);
.LINE 86

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__22
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%8
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	A,%78
	LD	(___print_fmt+4),A
	LD	C,(IX+%FFFFFFE7)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFE4)
	PUSH	BC
	CALL	__u_ultoa
	POP	BC
	POP	BC
	LD	BC,L__23
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   87	
;   88		if(crcexpected != crcresult)
.LINE 88

	LD	HL,(IX+%FFFFFFE4)
	LD	E,(IX+%FFFFFFE7)
	LD	BC,15434610
	LD	A,%C7
	CALL	__lcmpu
	JR	Z,L_17
;   89		{
;   90			printf("\n\rMismatch, aborting - please push reset button");
.LINE 90

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__25
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   91			while(1);
L_15:
.LINE 91

	JR	L_15
;   92		}
L_17:
.LINE 92

;   93		printf("\n\rOK\n\r\n\r");
.LINE 93

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__26
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   94	
;   95		// Ask user to continue
;   96		printf("Erase and program flash (y/n)? ");
.LINE 96

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__27
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   97		response = 0;
.LINE 97

	LD	(IX+%FFFFFFF9),%0
;   98		while((response != 'y') && (response != 'n')) response = getch();
.LINE 98

	JR	L_19
L_20:
	CALL	_getch
	LD	(IX+%FFFFFFF9),A
L_19:
	LD	A,(IX+%FFFFFFF9)
	CP	A,%79
	JR	Z,L_62
	LD	A,(IX+%FFFFFFF9)
	CP	A,%6E
	JR	NZ,L_20
L_62:
;   99		if(response == 'y')
.LINE 99

	LD	A,(IX+%FFFFFFF9)
	CP	A,%79
	JR	NZ,L_61
;  100		{
;  101			printf("\r\nBacking up existing firmware... ");
.LINE 101

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__31
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  102			fastmemcpy(BUFFER2, 0x0, FLASHSIZE);	
.LINE 102

	LD	BC,131072
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,458752
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
;  103			crcbackup = crc32((char*)0x0, FLASHSIZE);
.LINE 103

	LD	BC,131072
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFD6),HL
	LD	(IX+%FFFFFFD9),E
;  104			
;  105			di();								// prohibit any access to the old MOS firmware
.LINE 105

	di
;  106	
;  107			// start address in flash
;  108			addressto = FLASHSTART;
.LINE 108

	LD	BC,0
	LD	(IX+%FFFFFFE9),BC
;  109			addressfrom = BUFFER1;
.LINE 109

	LD	BC,327680
	LD	(IX+%FFFFFFF5),BC
;  110			
;  111			state = firmware;		
.LINE 111

	LD	BC,0
	LD	(IX+%FFFFFFF2),BC
;  112			while(1)
L_59:
.LINE 112

;  113			{
;  114				switch(state)
.LINE 114

	LD	HL,(IX+%FFFFFFF2)
	CALL	__case8D
	JP	(HL)
L__32:
	DW	2
	DB	0
	DW24	L_21	

	DB	1
	DW24	L_22	

	DW24	L_23	

;  115				{
;  116					case firmware:
L_21:
.LINE 116

;  117						// start address in flash
;  118						addressfrom = BUFFER1;					
.LINE 118

	LD	BC,327680
	LD	(IX+%FFFFFFF5),BC
;  119						break;
.LINE 119

	JR	L_29
;  120					case recover:
L_22:
.LINE 120

;  121						// start address in flash
;  122						addressfrom = BUFFER2;
.LINE 122

	LD	BC,458752
	LD	(IX+%FFFFFFF5),BC
;  123						size = FLASHSIZE;			// entire backup buffer
.LINE 123

	LD	BC,131072
	LD	(IX+%FFFFFFFA),BC
;  124						break;
.LINE 124

	JR	L_29
;  125					default:
L_23:
.LINE 125

;  126						// RESET SYSTEM
;  127						printf("\r\n");
.LINE 127

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__33
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  128						for(counter = 9; counter >0; counter--)
.LINE 128

	LD	BC,9
	LD	(IX+%FFFFFFFD),BC
	JR	L_27
L_25:
;  129						{
;  130							printf("\rReset in %ds",counter);
.LINE 130

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__34
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%FFFFFFFD)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,115
	PUSH	BC
	CALL	___print_uputch
	POP	BC
;  131							delayms(1000);
.LINE 131

	LD	BC,1000
	PUSH	BC
	CALL	_delayms
	POP	BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFD),IY
;  132						}
L_27:
.LINE 132

	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	C,L_25
;  133						reset();
.LINE 133

	CALL	_reset
;  134				}
L_29:
.LINE 134

;  135		
;  136				// Unprotect and erase flash
;  137				printf("\r\nErasing flash... ");
.LINE 137

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__36
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  138				enableFlashKeyRegister();	// unlock Flash Key Register, so we can write to the Flash Write/Erase protection registers
.LINE 138

	CALL	_enableFlashKeyRegister
;  139				FLASH_PROT = 0;				// disable protection on all 8x16KB blocks in the flash
.LINE 139

	XOR	A,A
	OUT0	(250),A
;  140				enableFlashKeyRegister();	// will need to unlock again after previous write to the flash protection register
.LINE 140

	CALL	_enableFlashKeyRegister
;  141				FLASH_FDIV = 0x5F;			// Ceiling(18Mhz * 5,1us) = 95, or 0x5F
.LINE 141

	LD	A,%5F
	OUT0	(249),A
;  142				
;  143				for(counter = 0; counter < FLASHPAGES; counter++)
.LINE 143

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_35
L_33:
;  144				{
;  145					FLASH_PAGE = counter;
.LINE 145

	LD	A,(IX+%FFFFFFFD)
	OUT0	(252),A
;  146					FLASH_PGCTL = 0x02;			// Page erase bit enable, start erase
.LINE 146

	LD	A,%2
	OUT0	(255),A
;  147	
;  148					do
L_31:
.LINE 148

;  149					{
;  150						value = FLASH_PGCTL;
.LINE 150

	IN0	A,(255)
	LD	(IX+%FFFFFFE8),A
;  151					}
;  152					while(value & 0x02);// wait for completion of erase			
.LINE 152

	AND	A,%2
	JR	NZ,L_31
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  153				}
L_35:
.LINE 153

	LD	BC,128
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_33
;  154				
;  155				printf("\r\nWriting new firmware...\r\n");
.LINE 155

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__39
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  156				
;  157				// determine number of pages to write
;  158				pagemax = size/PAGESIZE;
.LINE 158

	LD	HL,(IX+%FFFFFFFA)
	LD	A,%A
	CALL	__ishru_b
	LD	(IX+%FFFFFFEF),HL
;  159				if(size%PAGESIZE) // last page has less than PAGESIZE bytes
.LINE 159

	LD	BC,1023
	LD	HL,(IX+%FFFFFFFA)
	CALL	__iand
	LD	(IX+%FFFFFFDE),HL
	CALL	__icmpzero
	JR	Z,L_38
;  160				{
;  161					pagemax += 1;
.LINE 161

	LD	BC,(IX+%FFFFFFEF)
	INC	BC
	LD	(IX+%FFFFFFEF),BC
;  162					lastpagebytes = size%PAGESIZE;			
.LINE 162

	LD	BC,(IX+%FFFFFFDE)
	LD	(IX+%FFFFFFE1),BC
;  163				}
;  164				else lastpagebytes = PAGESIZE; // normal last page
.LINE 164

	JR	L_46
L_38:
	LD	BC,1024
	LD	(IX+%FFFFFFE1),BC
L_46:
;  165				
;  166				// write out each page to flash
;  167				for(counter = 0; counter < pagemax; counter++)
.LINE 167

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_45
L_43:
;  168				{
;  169					printf("\rWriting flash page %03d/%03d", counter+1, pagemax);
.LINE 169

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__41
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%3
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,47
	PUSH	BC
	CALL	___print_uputch
	POP	BC
	LD	A,%3
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	BC,(IX+%FFFFFFEF)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
;  170					
;  171					if(counter == (pagemax - 1)) // last page to write - might need to write less than PAGESIZE
.LINE 171

	LD	IY,(IX+%FFFFFFEF)
	LEA	HL,IY+%FFFFFFFF
	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_41
;  172						fastmemcpy(addressto,addressfrom,lastpagebytes);				
.LINE 172

	LD	BC,(IX+%FFFFFFE1)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	BC,(IX+%FFFFFFE9)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
;  173						//printf("Fake copy to %lx, from %lx, %lx bytes\r\n",addressto, addressfrom, lastpagebytes);
;  174					else 
.LINE 174

	JR	L_42
L_41:
;  175						fastmemcpy(addressto,addressfrom,PAGESIZE);
.LINE 175

	LD	BC,1024
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	BC,(IX+%FFFFFFE9)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
L_42:
;  176						//printf("Fake copy to %lx, from %lx, %lx bytes\r\n",addressto, addressfrom, PAGESIZE);
;  177				
;  178					addressto += PAGESIZE;
.LINE 178

	LD	BC,1024
	LD	HL,(IX+%FFFFFFE9)
	ADD	HL,BC
	LD	(IX+%FFFFFFE9),HL
;  179					addressfrom += PAGESIZE;
.LINE 179

	LD	HL,(IX+%FFFFFFF5)
	ADD	HL,BC
	LD	(IX+%FFFFFFF5),HL
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  180				}
L_45:
.LINE 180

	LD	BC,(IX+%FFFFFFEF)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_43
;  181				lockFlashKeyRegister();	// lock the flash before WARM reset
.LINE 181

	CALL	_lockFlashKeyRegister
;  182				printf("\r\n");
.LINE 182

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__44
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  183				
;  184				//Verify correct CRC in flash
;  185				printf("Verifying flash checksum... ");
.LINE 185

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__45
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  186				crcresult = crc32((char*)FLASHSTART, size);
.LINE 186

	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE4),HL
	LD	(IX+%FFFFFFE7),E
;  187	
;  188				if(state == recover) crcexpected = crcbackup;
.LINE 188

	LD	BC,1
	LD	HL,(IX+%FFFFFFF2)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_57
	LD	BC,(IX+%FFFFFFD6)
	LD	A,(IX+%FFFFFFD9)
	LD	(IX+%FFFFFFDA),BC
	LD	(IX+%FFFFFFDD),A
L_57:
;  189				
;  190				if(crcresult == crcexpected)
.LINE 190

	LD	HL,(IX+%FFFFFFE4)
	LD	E,(IX+%FFFFFFE7)
	LD	BC,(IX+%FFFFFFDA)
	LD	A,(IX+%FFFFFFDD)
	CALL	__lcmpu
	JR	NZ,L_56
;  191				{
;  192					printf("- OK\r\n");
.LINE 192

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__48
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  193					state = systemreset;
.LINE 193

	LD	BC,2
	LD	(IX+%FFFFFFF2),BC
;  194				}
;  195				else // CRC Failure - next action depends on current state
.LINE 195

	JR	L_59
L_56:
;  196				{	 // User interaction not possible without MOS handling interrupts
;  197					switch(state)
.LINE 197

	LD	HL,(IX+%FFFFFFF2)
	CALL	__case8D
	JP	(HL)
L__49:
	DW	2
	DB	0
	DW24	L_49	

	DB	1
	DW24	L_50	

	DW24	L_53	

;  198					{
;  199						case firmware:
L_49:
.LINE 199

;  200							printf("\r\nError occured during flash write\r\nAttempting to flash backup firmware...\r\n");
.LINE 200

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__50
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  201							state = recover;
.LINE 201

	LD	BC,1
	LD	(IX+%FFFFFFF2),BC
;  202							break;
.LINE 202

	JR	L_59
;  203						case recover:
L_50:
.LINE 203

;  204							printf("\r\nError occured during flash write\r\nBackup recovery failed\r\n");
.LINE 204

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__51
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  205							while(1); // no more options unfortunately, system needs a firmware programmer
L_52:
.LINE 205

	JR	L_52
;  206						default:
L_53:
.LINE 206

;  207							state = recover;
.LINE 207

	LD	BC,1
	LD	(IX+%FFFFFFF2),BC
	JR	L_59
;  208					}
;  209				}
;  210			}		
;  211		}
;  212		else printf("\n\rUser abort - please push reset button");
L_61:
.LINE 212

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__52
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  213		
;  214		while(1);
L_64:
.LINE 214

	JR	L_64
;  215	}
.LINE 215

	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_lockFlashKeyRegister               IMPORT  -----   function
;_enableFlashKeyRegister             IMPORT  -----   function
;_reset                              IMPORT  -----   function
;_delayms                            IMPORT  -----   function
;_fastmemcpy                         IMPORT  -----   function
;_getch                              IMPORT  -----   function
;_crc32                              IMPORT  -----   function
;__u_ultoa                           IMPORT  -----   function
;___print_fmt                        IMPORT     19   variable
;_mos_fclose                         IMPORT  -----   function
;_mos_feof                           IMPORT  -----   function
;_mos_fgetc                          IMPORT  -----   function
;__u_itoa                            IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;crcbackup                            IX-42      4   variable
;crcexpected                          IX-38      4   variable
;G_0                                  IX-34      3   variable
;lastpagebytes                        IX-31      3   variable
;crcresult                            IX-28      4   variable
;value                                IX-24      1   variable
;addressto                            IX-23      3   variable
;ptr                                  IX-20      3   variable
;pagemax                              IX-17      3   variable
;state                                IX-14      3   variable
;addressfrom                          IX-11      3   variable
;file                                  IX-8      1   variable
;response                              IX-7      1   variable
;size                                  IX-6      3   variable
;counter                               IX-3      3   variable
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 57 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "main",215,"_main"
	SEGMENT STRSECT
L__2:
	DB	"Agon MOS firmware upgrade utility"
	DB	10,13,0
L__3:
	DB	"This utility will upgrade an existing 1.00/1.01 firmware to 1.03rc1"
	DB	13,10,13,10,0
L__4:
	DB	"firmware103rc1.bin"
	DB	0
L__6:
	DB	"Error opening \""
	DB	0
L__7:
	DB	"firmware103rc1.bin"
	DB	0
L__8:
	DB	"\" - please push reset button"
	DB	0
L__9:
	DB	"Loading file : "
	DB	0
L__10:
	DB	"firmware103rc1.bin"
	DB	0
L__11:
	DB	10,13,0
L__12:
	DB	"File size    : "
	DB	0
L__13:
	DB	" byte(s)"
	DB	0
L__15:
	DB	13
	DB	"File size    : "
	DB	0
L__16:
	DB	" byte(s)"
	DB	0
L__18:
	DB	13
	DB	"File size    : "
	DB	0
L__19:
	DB	" byte(s)"
	DB	10,13,0
L__20:
	DB	"Testing CRC32: 0x"
	DB	0
L__21:
	DB	10,13,0
L__22:
	DB	"CRC32 result : 0x"
	DB	0
L__23:
	DB	10,13,0
L__25:
	DB	10,13
	DB	"Mismatch, aborting - please push reset button"
	DB	0
L__26:
	DB	10,13
	DB	"OK"
	DB	10,13,10,13,0
L__27:
	DB	"Erase and program flash (y/n)? "
	DB	0
L__31:
	DB	13,10
	DB	"Backing up existing firmware... "
	DB	0
L__33:
	DB	13,10,0
L__34:
	DB	13
	DB	"Reset in "
	DB	0
L__36:
	DB	13,10
	DB	"Erasing flash... "
	DB	0
L__39:
	DB	13,10
	DB	"Writing new firmware..."
	DB	13,10,0
L__41:
	DB	13
	DB	"Writing flash page "
	DB	0
L__44:
	DB	13,10,0
L__45:
	DB	"Verifying flash checksum... "
	DB	0
L__48:
	DB	"- OK"
	DB	13,10,0
L__50:
	DB	13,10
	DB	"Error occured during flash write"
	DB	13,10
	DB	"Attempting to flash backup firmware..."
	DB	13,10,0
L__51:
	DB	13,10
	DB	"Error occured during flash write"
	DB	13,10
	DB	"Backup recovery failed"
	DB	13,10,0
L__52:
	DB	10,13
	DB	"User abort - please push reset button"
	DB	0
	XREF _crc32:ROM
	XREF _delayms:ROM
	XREF _reset:ROM
	XREF _fastmemcpy:ROM
	XREF _lockFlashKeyRegister:ROM
	XREF _enableFlashKeyRegister:ROM
	XREF _mos_feof:ROM
	XREF _mos_fgetc:ROM
	XREF _mos_fclose:ROM
	XREF _mos_fopen:ROM
	XREF _getch:ROM
	XREF __u_ultoa:ROM
	XREF __u_itoa:ROM
	XREF ___print_sendstring:ROM
	XREF ___print_xputch:ROM
	XREF ___print_uputch:ROM
	XREF ___print_fmt:ROM
	XREF __lcmpu:ROM
	XREF __iand:ROM
	XREF __icmpzero:ROM
	XREF __case8D:ROM
	XREF __ishru_b:ROM
	XDEF _main
	XDEF _putch
	XDEF _errno
	END
