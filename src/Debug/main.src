; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\main.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
	SEGMENT BSS
_errno:
	DS	3
.DEFINE "errno"
.ALIAS "_errno"
.CLASS 83
.VALUE _errno
.TYPE 4
.ENDEF
;    1	/*
;    2	 * Title:			Agon MOS firmware upgrade utility
;    3	 * Author:			Jeroen Venema
;    4	 * Created:			17/12/2022
;    5	 * Last Updated:	17/12/2022
;    6	 * 
;    7	 * Modinfo:
;    8	 * 17/12/2022:		Initial version
;    9	 * 05/04/2022:		Changed timer to 5sec at reset.
;   10	 *                  Sends cls just before reset
;   11	 * 07/06/2023:		Included faster crc32, by Leigh Brown
;   12	 */
;   13	
;   14	#include <ez80.h>
;   15	#include <stdio.h>
;   16	#include <stdlib.h>
;   17	#include <ERRNO.H>
;   18	#include "mos-interface.h"
;   19	#include "flash.h"
;   20	#include "agontimer.h"
;   21	#include "crc32.h"
;   22	#include "filesize.h"
;   23	#include "./stdint.h"
;   24	#include <string.h>
;   25	
;   26	#define UNLOCKMATCHLENGTH 9
;   27	
;   28	#define EXIT_FILENOTFOUND	4
;   29	#define EXIT_INVALIDPARAMETER	19
;   30	
;   31	int errno; // needed by standard library
	SEGMENT CODE
;   32	enum states{firmware,recover,systemreset};
;   33	
;   34	// separate putch function that doesn't rely on a running MOS firmware
;   35	// UART0 initialization done by MOS firmware previously
;   36	// This utility doesn't run without MOS to load it anyway
;   37	int putch(int c)
;   38	{
_putch:
.DEFINE "_putch"

.VALUE _putch

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "putch",38,"_putch"

.LINE 38

.DEFINE "c"

.CLASS 65

.VALUE 6

.TYPE 4

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
.ENDEF

;   39		UINT8 lsr,temt;
;   40		
;   41		while((UART0_LSR & 0x40) == 0);
L_1:
.LINE 41

	IN0	A,(197)
	AND	A,%40
	UEXT	HL
	LD	L,A
	CALL	__icmpzero
	JR	Z,L_1
;   42		UART0_THR = c;
.LINE 42

	LD	A,(IX+%6)
	OUT0	(192),A
;   43		return c;
.LINE 43

	LD	HL,(IX+%6)
;   44	}
.LINE 44

	LD	SP,IX
	POP	IX
	RET	


;**************************** _putch ***************************
;Name                         Addr/Register   Size   Type
;c                                     IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "putch",44,"_putch"
;   45	
;   46	uint8_t getCharAt(uint16_t x, uint16_t y) {
_getCharAt:
.DEFINE "_getCharAt"

.VALUE _getCharAt

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "getCharAt",46,"_getCharAt"

.LINE 46

.DEFINE "x"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   47		delayms(20);
.LINE 47

	LD	BC,20
	PUSH	BC
	CALL	_delayms
	POP	BC
;   48		putch(23);
.LINE 48

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;   49		putch(0);
.LINE 49

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;   50		putch(131);
.LINE 50

	LD	BC,131
	PUSH	BC
	CALL	_putch
	POP	BC
;   51		putch(x & 0xFF);
.LINE 51

	LD	BC,(IX+%6)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   52		putch((x >> 8) & 0xFF);
.LINE 52

	LD	BC,(IX+%6)
	CALL	__stoiu
	LD	A,%8
	CALL	__ishrs_b
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   53		putch(y & 0xFF);
.LINE 53

	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   54		putch((y >> 8) & 0xFF);
.LINE 54

	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	A,%8
	CALL	__ishrs_b
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   55		delayms(20);
.LINE 55

	LD	BC,20
	PUSH	BC
	CALL	_delayms
	POP	BC
;   56		return getsysvar_scrchar();
.LINE 56

	CALL	_getsysvar_scrchar
;   57	}
.LINE 57

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getCharAt ***************************
;Name                         Addr/Register   Size   Type
;_getsysvar_scrchar                  IMPORT  -----   function
;_putch                              IMPORT  -----   function
;_delayms                            IMPORT  -----   function
;y                                     IX+9      2   parameter
;x                                     IX+6      2   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getCharAt",57,"_getCharAt"
;   58	
;   59	bool vdp_ota_present(void) {
_vdp_ota_present:
.DEFINE "_vdp_ota_present"

.VALUE _vdp_ota_present

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "vdp_ota_present",59,"_vdp_ota_present"

.LINE 59

.DEFINE "n"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "test"

.CLASS 65

.VALUE -11

.DIM 9

.TYPE 98

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF5
	LD	SP,HL
;   60		char test[UNLOCKMATCHLENGTH];
;   61		uint16_t n;
;   62	
;   63		putch(23);
.LINE 63

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;   64		putch(29);
.LINE 64

	LD	BC,29
	PUSH	BC
	CALL	_putch
	POP	BC
;   65		putch(0);
.LINE 65

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;   66		printf("unlock");
.LINE 66

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__3
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   67	
;   68		for(n = 0; n < UNLOCKMATCHLENGTH+1; n++) test[n] = getCharAt(n+8, 3);
.LINE 68

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_8
L_6:
	LD	BC,3
	PUSH	BC
	LD	IY,(IX+%FFFFFFFE)
	LEA	BC,IY+%8
	PUSH	BC
	CALL	_getCharAt
	POP	BC
	POP	BC
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,HL
	LEA	HL,IX+%FFFFFFF5
	ADD	HL,BC
	LD	(HL),A
	LD	HL,(IX+%FFFFFFFE)
	INC	HL
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
L_8:
	LD.LIS	BC,10
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_6
;   69		// 3 - line on-screen
;   70		if(memcmp(test, "unlocked!",UNLOCKMATCHLENGTH) == 0) return true;
.LINE 70

	LD	BC,9
	PUSH	BC
	LD	BC,L__5
	PUSH	BC
	PEA	IX+%FFFFFFF5
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_10
	LD	A,%1
	JR	L_12
;   71		else return false;
L_10:
.LINE 71

	XOR	A,A
;   72	}
L_12:
.LINE 72

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vdp_ota_present ***************************
;Name                         Addr/Register   Size   Type
;_memcmp                             IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_putch                              IMPORT  -----   function
;test                                 IX-11      9   variable
;n                                     IX-2      2   variable


; Stack Frame Size: 17 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vdp_ota_present",72,"_vdp_ota_present"
	SEGMENT STRSECT
L__3:
	DB	"unlock"
	DB	0
L__5:
	DB	"unlocked!"
	DB	0
	SEGMENT DATA
_mos_magicnumbers:
	DB	243
	DB	237
	DB	125
	DB	91
	DB	195
.DEFINE "mos_magicnumbers"
.ALIAS "_mos_magicnumbers"
.CLASS 69
.VALUE _mos_magicnumbers
.DIM 5
.TYPE 108
.ENDEF
;   73	
;   74	uint8_t mos_magicnumbers[] = {0xF3, 0xED, 0x7D, 0x5B, 0xC3};
	SEGMENT CODE
;   75	#define MOS_MAGICLENGTH 5
;   76	bool containsMosHeader(uint8_t *filestart) {
_containsMosHeader:
.DEFINE "_containsMosHeader"

.VALUE _containsMosHeader

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "containsMosHeader",76,"_containsMosHeader"

.LINE 76

.DEFINE "filestart"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "match"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;   77		uint8_t n;
;   78		bool match = true;
.LINE 78

	LD	(IX+%FFFFFFFE),%1
;   79	
;   80		for(n = 0; n < MOS_MAGICLENGTH; n++) if(mos_magicnumbers[n] != filestart[n]) match = false;
.LINE 80

	LD	(IX+%FFFFFFFF),%0
	JR	L_17
L_15:
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,_mos_magicnumbers
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_16
	LD	(IX+%FFFFFFFE),%0
L_16:
	INC	(IX+%FFFFFFFF)
L_17:
	LD	A,(IX+%FFFFFFFF)
	CP	A,%5
	JR	C,L_15
;   81		return match;
.LINE 81

	LD	A,(IX+%FFFFFFFE)
;   82	}
.LINE 82

	LD	SP,IX
	POP	IX
	RET	


;**************************** _containsMosHeader ***************************
;Name                         Addr/Register   Size   Type
;_mos_magicnumbers                   STATIC      5   variable
;match                                 IX-2      1   variable
;n                                     IX-1      1   variable
;filestart                             IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "containsMosHeader",82,"_containsMosHeader"
	SEGMENT DATA
_esp32_magicnumbers:
	DB	50
	DB	84
	DB	205
	DB	171
.DEFINE "esp32_magicnumbers"
.ALIAS "_esp32_magicnumbers"
.CLASS 69
.VALUE _esp32_magicnumbers
.DIM 4
.TYPE 108
.ENDEF
;   83	
;   84	uint8_t esp32_magicnumbers[] = {0x32, 0x54, 0xCD, 0xAB};
	SEGMENT CODE
;   85	#define ESP32_MAGICLENGTH 4
;   86	#define ESP32_MAGICSTART 0x20
;   87	bool containsESP32Header(uint8_t *filestart) {
_containsESP32Header:
.DEFINE "_containsESP32Header"

.VALUE _containsESP32Header

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "containsESP32Header",87,"_containsESP32Header"

.LINE 87

.DEFINE "filestart"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "match"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;   88		uint8_t n;
;   89		bool match = true;
.LINE 89

	LD	(IX+%FFFFFFFE),%1
;   90	
;   91		filestart += ESP32_MAGICSTART; // start of ESP32 magic header
.LINE 91

	LD	IY,(IX+%6)
	LEA	IY,IY+%20
	LD	(IX+%6),IY
;   92		for(n = 0; n < ESP32_MAGICLENGTH; n++) {
.LINE 92

	LD	(IX+%FFFFFFFF),%0
	JR	L_24
L_22:
;   93			if(esp32_magicnumbers[n] != filestart[n]) match = false;
.LINE 93

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,_esp32_magicnumbers
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_23
	LD	(IX+%FFFFFFFE),%0
;   94		}
L_23:
.LINE 94

	INC	(IX+%FFFFFFFF)
L_24:
	LD	A,(IX+%FFFFFFFF)
	CP	A,%4
	JR	C,L_22
;   95		return match;
.LINE 95

	LD	A,(IX+%FFFFFFFE)
;   96	}
.LINE 96

	LD	SP,IX
	POP	IX
	RET	


;**************************** _containsESP32Header ***************************
;Name                         Addr/Register   Size   Type
;_esp32_magicnumbers                 STATIC      4   variable
;match                                 IX-2      1   variable
;n                                     IX-1      1   variable
;filestart                             IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "containsESP32Header",96,"_containsESP32Header"
;   97	
;   98	void print_version(void) {
_print_version:
.DEFINE "_print_version"

.VALUE _print_version

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "print_version",98,"_print_version"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   99		printf("Agon firmware upgrade utility v1.4\n\r\n\r");
.LINE 99

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__14
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  100	}
.LINE 100

	LD	SP,IX
	POP	IX
	RET	


;**************************** _print_version ***************************
;Name                         Addr/Register   Size   Type
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "print_version",100,"_print_version"
	SEGMENT STRSECT
L__14:
	DB	"Agon firmware upgrade utility v1.4"
	DB	10,13,10,13,0
	SEGMENT CODE
;  101	
;  102	void usage(void) {
_usage:
.DEFINE "_usage"

.VALUE _usage

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "usage",102,"_usage"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  103		print_version();
.LINE 103

	CALL	_print_version
;  104		printf("Usage: FLASH <mos|vdp> <filename>\n\r");
.LINE 104

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__16
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  105	}
.LINE 105

	LD	SP,IX
	POP	IX
	RET	


;**************************** _usage ***************************
;Name                         Addr/Register   Size   Type
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "usage",105,"_usage"
	SEGMENT STRSECT
L__16:
	DB	"Usage: FLASH <mos|vdp> <filename>"
	DB	10,13,0
	SEGMENT CODE
;  106	
;  107	typedef enum {
;  108		MOS,
;  109		VDP
;  110	} flashtype;
;  111	
;  112	bool getResponse(flashtype t, uint32_t crc) {
_getResponse:
.DEFINE "_getResponse"

.VALUE _getResponse

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "getResponse",112,"_getResponse"

.LINE 112

.DEFINE "t"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "crc"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "response"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;  113		uint8_t response = 0;
.LINE 113

	LD	(IX+%FFFFFFFF),%0
;  114	
;  115		switch(t) {
.LINE 115

	LD	HL,(IX+%6)
	CALL	__case8D
	JP	(HL)
L__18:
	DW	2
	DB	0
	DW24	L_29	

	DB	1
	DW24	L_30	

	DW24	L_32	

;  116			case MOS:
L_29:
.LINE 116

;  117				printf("\r\n\r\n0x%04lX - flash to MOS (y/n)?", crc);
.LINE 117

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__19
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%4
	LD	(___print_fmt+5),A
	LD	A,%60
	LD	(___print_fmt+1),A
	LD	A,%78
	LD	(___print_fmt+4),A
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	__u_ultoa
	POP	BC
	POP	BC
	LD	BC,L__20
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  118				break;
.LINE 118

	JR	L_32
;  119			case VDP:
L_30:
.LINE 119

;  120				printf("\r\n\r\n0x%04lX - flash to VDP (y/n)?", crc);
.LINE 120

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__21
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%4
	LD	(___print_fmt+5),A
	LD	A,%60
	LD	(___print_fmt+1),A
	LD	A,%78
	LD	(___print_fmt+4),A
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	__u_ultoa
	POP	BC
	POP	BC
	LD	BC,L__22
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  121				break;
.LINE 121

	JR	L_32
;  122		}
;  123	
;  124		while((response != 'y') && (response != 'n')) response = getch();
L_33:
.LINE 124

	CALL	_getch
	LD	(IX+%FFFFFFFF),A
L_32:
	LD	A,(IX+%FFFFFFFF)
	CP	A,%79
	JR	Z,L_35
	LD	A,(IX+%FFFFFFFF)
	CP	A,%6E
	JR	NZ,L_33
L_35:
;  125		printf("\r\nUser abort\n\r\n\r");
.LINE 125

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__25
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  126		return response == 'y';
.LINE 126

	LD	A,(IX+%FFFFFFFF)
	CP	A,%79
	JR	NZ,L__27
	LD	A,%1
	JR	L__28
L__27:
	XOR	A,A
L__28:
;  127	}
.LINE 127

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getResponse ***************************
;Name                         Addr/Register   Size   Type
;_getch                              IMPORT  -----   function
;__u_ultoa                           IMPORT  -----   function
;___print_fmt                        IMPORT     19   variable
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;response                              IX-1      1   variable
;crc                                   IX+9      4   parameter
;t                                     IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getResponse",127,"_getResponse"
	SEGMENT STRSECT
L__19:
	DB	13,10,13,10
	DB	"0x"
	DB	0
L__20:
	DB	" - flash to MOS (y/n)?"
	DB	0
L__21:
	DB	13,10,13,10
	DB	"0x"
	DB	0
L__22:
	DB	" - flash to VDP (y/n)?"
	DB	0
L__25:
	DB	13,10
	DB	"User abort"
	DB	10,13,10,13,0
	SEGMENT CODE
;  128	
;  129	uint8_t update_vdp(char *filename) {
_update_vdp:
.DEFINE "_update_vdp"

.VALUE _update_vdp

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "update_vdp",129,"_update_vdp"

.LINE 129

.DEFINE "filename"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "size"

.CLASS 65

.VALUE -4

.TYPE 14

.ENDEF

.DEFINE "filesize"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

.DEFINE "crcresult"

.CLASS 65

.VALUE -11

.TYPE 15

.ENDEF

.DEFINE "buffer"

.CLASS 65

.VALUE -47

.DIM 36

.TYPE 108

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFD1
	LD	SP,HL
;  130		uint8_t file;
;  131		uint8_t buffer[ESP32_MAGICLENGTH + ESP32_MAGICSTART];
;  132		uint24_t filesize;
;  133		uint32_t crcresult;
;  134		uint24_t size, n;
;  135		uint8_t response;
;  136	
;  137		putch(12); // cls
.LINE 137

	LD	BC,12
	PUSH	BC
	CALL	_putch
	POP	BC
;  138		print_version();	
.LINE 138

	CALL	_print_version
;  139		printf("Unlocking VDP updater...\r\n");
.LINE 139

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__30
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  140		
;  141		if(!vdp_ota_present()) {
.LINE 141

	CALL	_vdp_ota_present
	OR	A,A
	JR	NZ,L_38
;  142			printf(" failed - incompatible VDP\r\n");
.LINE 142

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__32
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  143			return 0;
.LINE 143

	XOR	A,A
	JR	L_50
;  144		}
L_38:
.LINE 144

;  145	
;  146		file = mos_fopen(filename, fa_read);
.LINE 146

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  147		if(!file) {
.LINE 147

	OR	A,A
	JR	NZ,L_40
;  148			printf("Error opening \"%s\"\n\r",filename);
.LINE 148

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__34
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__35
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  149			return EXIT_FILENOTFOUND;
.LINE 149

	LD	A,%4
	JR	L_50
;  150		}
L_40:
.LINE 150

;  151	
;  152		mos_fread(file, (char *)buffer, ESP32_MAGICLENGTH + ESP32_MAGICSTART);
.LINE 152

	LD	BC,36
	PUSH	BC
	PEA	IX+%FFFFFFD1
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  153		if(!containsESP32Header(buffer)) {
.LINE 153

	PEA	IX+%FFFFFFD1
	CALL	_containsESP32Header
	POP	BC
	OR	A,A
	JR	NZ,L_42
;  154			printf("File does not contain valid ESP32 code\r\n");
.LINE 154

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__37
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  155			mos_fclose(file);
.LINE 155

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  156			return EXIT_INVALIDPARAMETER;
.LINE 156

	LD	A,%13
	JR	L_50
;  157		}
L_42:
.LINE 157

;  158		printf("\r\nValid ESP32 code\r\nCalculating CRC32");
.LINE 158

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__38
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  159		crc32_initialize();
.LINE 159

	CALL	_crc32_initialize
;  160		mos_flseek(file, 0);
.LINE 160

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  161		while(1) {
L_46:
.LINE 161

;  162			size = mos_fread(file, (char *)BUFFER1, BLOCKSIZE);
.LINE 162

	LD	BC,16384
	PUSH	BC
	LD	BC,327680
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),HL
;  163			if(size == 0) break;
.LINE 163

	CALL	__icmpzero
	JR	Z,L_47
;  164			putch('.');
.LINE 164

	LD	BC,46
	PUSH	BC
	CALL	_putch
	POP	BC
;  165			crc32((char *)BUFFER1, size);
.LINE 165

	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	BC,327680
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
	JR	L_46
;  166		}
L_47:
.LINE 166

;  167		crcresult = crc32_finalize();
.LINE 167

	CALL	_crc32_finalize
	LD	(IX+%FFFFFFF5),HL
	LD	(IX+%FFFFFFF8),E
;  168		if(!getResponse(VDP, crcresult)) {
.LINE 168

	LD	C,(IX+%FFFFFFF8)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	BC,1
	PUSH	BC
	CALL	_getResponse
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_49
;  169			mos_fclose(file);
.LINE 169

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  170			return 0;
.LINE 170

	XOR	A,A
	JR	L_50
;  171		}
L_49:
.LINE 171

;  172		// Do actual work here
;  173		mos_flseek(file, 0); // reset to zero, because we read part of the header already
.LINE 173

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  174		printf("Updating VDP firmware\r\n");
.LINE 174

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__41
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  175		filesize = getFileSize(file);	
.LINE 175

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_getFileSize
	POP	BC
	LD	(IX+%FFFFFFF9),HL
;  176		startVDPupdate(file, filesize);
.LINE 176

	LD	BC,HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_startVDPupdate
	POP	BC
	POP	BC
;  177		mos_fclose(file);
.LINE 177

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  178		reset();
.LINE 178

	CALL	_reset
;  179		return 0; // will never return, but let's give the compiler a break
.LINE 179

	XOR	A,A
;  180	}
L_50:
.LINE 180

	LD	SP,IX
	POP	IX
	RET	


;**************************** _update_vdp ***************************
;Name                         Addr/Register   Size   Type
;_reset                              IMPORT  -----   function
;_startVDPupdate                     IMPORT  -----   function
;_getFileSize                        IMPORT  -----   function
;_crc32_finalize                     IMPORT  -----   function
;_crc32                              IMPORT  -----   function
;_mos_flseek                         IMPORT  -----   function
;_crc32_initialize                   IMPORT  -----   function
;_mos_fclose                         IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_putch                              IMPORT  -----   function
;buffer                               IX-47     36   variable
;crcresult                            IX-11      4   variable
;filesize                              IX-7      3   variable
;size                                  IX-4      3   variable
;file                                  IX-1      1   variable
;filename                              IX+6      3   parameter


; Stack Frame Size: 56 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "update_vdp",180,"_update_vdp"
	SEGMENT STRSECT
L__30:
	DB	"Unlocking VDP updater..."
	DB	13,10,0
L__32:
	DB	" failed - incompatible VDP"
	DB	13,10,0
L__34:
	DB	"Error opening \""
	DB	0
L__35:
	DB	"\""
	DB	10,13,0
L__37:
	DB	"File does not contain valid ESP32 code"
	DB	13,10,0
L__38:
	DB	13,10
	DB	"Valid ESP32 code"
	DB	13,10
	DB	"Calculating CRC32"
	DB	0
L__41:
	DB	"Updating VDP firmware"
	DB	13,10,0
	SEGMENT CODE
;  181	
;  182	uint8_t update_mos(char *filename) {
_update_mos:
.DEFINE "_update_mos"

.VALUE _update_mos

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "update_mos",182,"_update_mos"

.LINE 182

.DEFINE "filename"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "counter"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "response"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

.DEFINE "addressfrom"

.CLASS 65

.VALUE -8

.TYPE 14

.ENDEF

.DEFINE "state"

.CLASS 65

.VALUE -11

.TYPE 4

.ENDEF

.DEFINE "pagemax"

.CLASS 65

.VALUE -14

.TYPE 14

.ENDEF

.DEFINE "addressto"

.CLASS 65

.VALUE -17

.TYPE 14

.ENDEF

.DEFINE "ptr"

.CLASS 65

.VALUE -20

.TYPE 34

.ENDEF

.DEFINE "size"

.CLASS 65

.VALUE -23

.TYPE 14

.ENDEF

.DEFINE "value"

.CLASS 65

.VALUE -24

.TYPE 12

.ENDEF

.DEFINE "got"

.CLASS 65

.VALUE -27

.TYPE 14

.ENDEF

.DEFINE "lastpagebytes"

.CLASS 65

.VALUE -30

.TYPE 14

.ENDEF

.DEFINE "crcresult"

.CLASS 65

.VALUE -34

.TYPE 15

.ENDEF

.DEFINE "filesize"

.CLASS 65

.VALUE -40

.TYPE 14

.ENDEF

.DEFINE "crcexpected"

.CLASS 65

.VALUE -44

.TYPE 15

.ENDEF

.DEFINE "crcbackup"

.CLASS 65

.VALUE -48

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFD0
	LD	SP,HL
;  183		UINT32 crcexpected,crcresult,crcbackup;
;  184		UINT24 size = 0;
.LINE 184

	LD	BC,0
	LD	(IX+%FFFFFFE9),BC
;  185		UINT24 got;
;  186		UINT8 file;
;  187		char* ptr = (char*)BUFFER1;
.LINE 187

	LD	BC,327680
	LD	(IX+%FFFFFFEC),BC
;  188		UINT8 response;
;  189		UINT8 value;
;  190		UINT24 counter,pagemax, lastpagebytes;
;  191		UINT24 addressto,addressfrom;
;  192		enum states state;
;  193		uint24_t filesize;
;  194	
;  195		putch(12); // cls
.LINE 195

	LD	BC,12
	PUSH	BC
	CALL	_putch
	POP	BC
;  196		print_version();	
.LINE 196

	CALL	_print_version
;  197		
;  198		file = mos_fopen(filename, fa_read);
.LINE 198

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),A
;  199		if(!file)
.LINE 199

	OR	A,A
	JR	NZ,L_52
;  200		{
;  201			printf("Error opening \"%s\"\n\r",filename);
.LINE 201

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__44
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__45
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  202			return EXIT_FILENOTFOUND;
.LINE 202

	LD	A,%4
	JR	L_112
;  203		}
L_52:
.LINE 203

;  204	
;  205		filesize = getFileSize(file);
.LINE 205

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_getFileSize
	POP	BC
	LD	(IX+%FFFFFFD8),HL
;  206		if(filesize > FLASHSIZE) {
.LINE 206

	LD	BC,HL
	LD	HL,131072
	OR	A,A
	SBC	HL,BC
	JR	NC,L_54
;  207			printf("Too large for 128KB embedded flash\r\n");
.LINE 207

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__47
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  208			mos_fclose(file);
.LINE 208

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  209			return EXIT_INVALIDPARAMETER;
.LINE 209

	LD	A,%13
	JR	L_112
;  210		}
L_54:
.LINE 210

;  211	
;  212		mos_fread(file, (char *)BUFFER1, MOS_MAGICLENGTH);
.LINE 212

	LD	BC,5
	PUSH	BC
	LD	BC,327680
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  213		if(!containsMosHeader((uint8_t *)BUFFER1)) {
.LINE 213

	LD	BC,327680
	PUSH	BC
	CALL	_containsMosHeader
	POP	BC
	OR	A,A
	JR	NZ,L_56
;  214			printf("File does not contain valid MOS ez80 startup code\r\n");
.LINE 214

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__49
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  215			mos_fclose(file);
.LINE 215

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  216			return EXIT_INVALIDPARAMETER;
.LINE 216

	LD	A,%13
	JR	L_112
;  217		}
L_56:
.LINE 217

;  218		printf("\r\nValid ez80 code\r\nCalculating CRC32");
.LINE 218

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__50
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  219	
;  220		crc32_initialize();
.LINE 220

	CALL	_crc32_initialize
;  221		mos_flseek(file, 0);
.LINE 221

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  222		
;  223		// Read file to memory
;  224		while((got = mos_fread(file, ptr, BLOCKSIZE)) > 0) {
.LINE 224

	JR	L_57
L_58:
;  225			crc32(ptr, got);
.LINE 225

	LD	BC,(IX+%FFFFFFE5)
	PUSH	BC
	LD	BC,(IX+%FFFFFFEC)
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
;  226			ptr += got;
.LINE 226

	LD	BC,(IX+%FFFFFFE5)
	LD	HL,(IX+%FFFFFFEC)
	ADD	HL,BC
	LD	(IX+%FFFFFFEC),HL
;  227			putch('.');
.LINE 227

	LD	BC,46
	PUSH	BC
	CALL	_putch
	POP	BC
;  228		}		
L_57:
.LINE 228

	LD	BC,16384
	PUSH	BC
	LD	BC,(IX+%FFFFFFEC)
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE5),HL
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	C,L_58
;  229		crcresult = crc32_finalize();
.LINE 229

	CALL	_crc32_finalize
	LD	(IX+%FFFFFFDE),HL
	LD	(IX+%FFFFFFE1),E
;  230		if(!getResponse(MOS, crcresult)) {
.LINE 230

	LD	C,(IX+%FFFFFFE1)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFDE)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_getResponse
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_61
;  231			mos_fclose(file);
.LINE 231

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  232			return 0;
.LINE 232

	XOR	A,A
	JR	L_112
;  233		}
L_61:
.LINE 233

;  234	
;  235		mos_fclose(file);
.LINE 235

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  236		return 0;	
.LINE 236

	XOR	A,A
	JR	L_112
;  237		
;  238		printf("\rFile size    : %d byte(s)\n\r", size);
;  239	
;  240		if(!containsMosHeader((uint8_t *)ptr)) {
;  241			printf("File does not contain valid MOS ez80 startup code\r\n");
;  242			return EXIT_INVALIDPARAMETER;
;  243		}
;  244	
;  245		crcexpected = 0;
;  246		printf("Testing CRC32: 0x%08lx\n\r",crcexpected);
;  247		crcresult = crc32((char*)BUFFER1, size);
;  248		printf("CRC32 result : 0x%08lx\n\r",crcresult);
;  249	
;  250		if(crcexpected != crcresult)
;  251		{
;  252			printf("\n\rMismatch - aborting\n\r");
;  253			return 0;
;  254		}
.LINE 254

;  255		printf("\n\rOK\n\r\n\r");
.LINE 255

;  256	
;  257		// Ask user to continue
;  258		printf("Erase and program flash (y/n)? ");
.LINE 258

;  259		response = 0;
.LINE 259

;  260		while((response != 'y') && (response != 'n')) response = getch();
.LINE 260

L_68:
	CALL	_getch
	LD	(IX+%FFFFFFFB),A
L_67:
	LD	A,(IX+%FFFFFFFB)
	CP	A,%79
	JR	Z,L_110
	LD	A,(IX+%FFFFFFFB)
	CP	A,%6E
	JR	NZ,L_68
L_110:
;  261		if(response == 'y')
.LINE 261

	LD	A,(IX+%FFFFFFFB)
	CP	A,%79
	JR	NZ,L_109
;  262		{
;  263			printf("\r\nBacking up existing firmware... ");
.LINE 263

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__58
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  264			fastmemcpy(BUFFER2, 0x0, FLASHSIZE);	
.LINE 264

	LD	BC,131072
	PUSH	BC
	LD	BC,0
	PUSH	BC
	LD	BC,458752
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
;  265			crcbackup = crc32((char*)0x0, FLASHSIZE);
.LINE 265

	LD	BC,131072
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFD0),HL
	LD	(IX+%FFFFFFD3),E
;  266			
;  267			di();								// prohibit any access to the old MOS firmware
.LINE 267

	di
;  268	
;  269			// start address in flash
;  270			addressto = FLASHSTART;
.LINE 270

	LD	BC,0
	LD	(IX+%FFFFFFEF),BC
;  271			addressfrom = BUFFER1;
.LINE 271

	LD	BC,327680
	LD	(IX+%FFFFFFF8),BC
;  272			
;  273			state = firmware;		
.LINE 273

	LD	BC,0
	LD	(IX+%FFFFFFF5),BC
;  274			while(1)
L_107:
.LINE 274

;  275			{
;  276				switch(state)
.LINE 276

	LD	HL,(IX+%FFFFFFF5)
	CALL	__case8D
	JP	(HL)
L__59:
	DW	2
	DB	0
	DW24	L_69	

	DB	1
	DW24	L_70	

	DW24	L_71	

;  277				{
;  278					case firmware:
L_69:
.LINE 278

;  279						// start address in flash
;  280						addressfrom = BUFFER1;					
.LINE 280

	LD	BC,327680
	LD	(IX+%FFFFFFF8),BC
;  281						break;
.LINE 281

	JR	L_77
;  282					case recover:
L_70:
.LINE 282

;  283						// start address in flash
;  284						addressfrom = BUFFER2;
.LINE 284

	LD	BC,458752
	LD	(IX+%FFFFFFF8),BC
;  285						size = FLASHSIZE;			// entire backup buffer
.LINE 285

	LD	BC,131072
	LD	(IX+%FFFFFFE9),BC
;  286						break;
.LINE 286

	JR	L_77
;  287					default:
L_71:
.LINE 287

;  288						// RESET SYSTEM
;  289						printf("\r\n");
.LINE 289

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__60
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  290						for(counter = 5; counter >0; counter--)
.LINE 290

	LD	BC,5
	LD	(IX+%FFFFFFFD),BC
	JR	L_75
L_73:
;  291						{
;  292							printf("\rReset in %ds",counter);
.LINE 292

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__61
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%FFFFFFFD)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,115
	PUSH	BC
	CALL	___print_uputch
	POP	BC
;  293							delayms(1000);
.LINE 293

	LD	BC,1000
	PUSH	BC
	CALL	_delayms
	POP	BC
	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFD),IY
;  294						}
L_75:
.LINE 294

	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	C,L_73
;  295						putch(12);
.LINE 295

	LD	BC,12
	PUSH	BC
	CALL	_putch
	POP	BC
;  296						delayms(500);
.LINE 296

	LD	BC,500
	PUSH	BC
	CALL	_delayms
	POP	BC
;  297						reset();
.LINE 297

	CALL	_reset
;  298				}
L_77:
.LINE 298

;  299		
;  300				// Unprotect and erase flash
;  301				printf("\r\nErasing flash... ");
.LINE 301

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__63
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  302				enableFlashKeyRegister();	// unlock Flash Key Register, so we can write to the Flash Write/Erase protection registers
.LINE 302

	CALL	_enableFlashKeyRegister
;  303				FLASH_PROT = 0;				// disable protection on all 8x16KB blocks in the flash
.LINE 303

	XOR	A,A
	OUT0	(250),A
;  304				enableFlashKeyRegister();	// will need to unlock again after previous write to the flash protection register
.LINE 304

	CALL	_enableFlashKeyRegister
;  305				FLASH_FDIV = 0x5F;			// Ceiling(18Mhz * 5,1us) = 95, or 0x5F
.LINE 305

	LD	A,%5F
	OUT0	(249),A
;  306				
;  307				for(counter = 0; counter < FLASHPAGES; counter++)
.LINE 307

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_83
L_81:
;  308				{
;  309					FLASH_PAGE = counter;
.LINE 309

	LD	A,(IX+%FFFFFFFD)
	OUT0	(252),A
;  310					FLASH_PGCTL = 0x02;			// Page erase bit enable, start erase
.LINE 310

	LD	A,%2
	OUT0	(255),A
;  311	
;  312					do
L_79:
.LINE 312

;  313					{
;  314						value = FLASH_PGCTL;
.LINE 314

	IN0	A,(255)
	LD	(IX+%FFFFFFE8),A
;  315					}
;  316					while(value & 0x02);// wait for completion of erase			
.LINE 316

	AND	A,%2
	JR	NZ,L_79
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  317				}
L_83:
.LINE 317

	LD	BC,128
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_81
;  318				
;  319				printf("\r\nWriting new firmware...\r\n");
.LINE 319

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__66
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  320				
;  321				// determine number of pages to write
;  322				pagemax = size/PAGESIZE;
.LINE 322

	LD	HL,(IX+%FFFFFFE9)
	LD	A,%A
	CALL	__ishru_b
	LD	(IX+%FFFFFFF2),HL
;  323				if(size%PAGESIZE) // last page has less than PAGESIZE bytes
.LINE 323

	LD	BC,1023
	LD	HL,(IX+%FFFFFFE9)
	CALL	__iand
	LD	(IX+%FFFFFFDB),HL
	CALL	__icmpzero
	JR	Z,L_86
;  324				{
;  325					pagemax += 1;
.LINE 325

	LD	BC,(IX+%FFFFFFF2)
	INC	BC
	LD	(IX+%FFFFFFF2),BC
;  326					lastpagebytes = size%PAGESIZE;			
.LINE 326

	LD	BC,(IX+%FFFFFFDB)
	LD	(IX+%FFFFFFE2),BC
;  327				}
;  328				else lastpagebytes = PAGESIZE; // normal last page
.LINE 328

	JR	L_94
L_86:
	LD	BC,1024
	LD	(IX+%FFFFFFE2),BC
L_94:
;  329				
;  330				// write out each page to flash
;  331				for(counter = 0; counter < pagemax; counter++)
.LINE 331

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_93
L_91:
;  332				{
;  333					printf("\rWriting flash page %03d/%03d", counter+1, pagemax);
.LINE 333

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__68
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%3
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,47
	PUSH	BC
	CALL	___print_uputch
	POP	BC
	LD	A,%3
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	BC,(IX+%FFFFFFF2)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
;  334					
;  335					if(counter == (pagemax - 1)) // last page to write - might need to write less than PAGESIZE
.LINE 335

	LD	IY,(IX+%FFFFFFF2)
	LEA	HL,IY+%FFFFFFFF
	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_89
;  336						fastmemcpy(addressto,addressfrom,lastpagebytes);				
.LINE 336

	LD	BC,(IX+%FFFFFFE2)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFEF)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
;  337						//printf("Fake copy to %lx, from %lx, %lx bytes\r\n",addressto, addressfrom, lastpagebytes);
;  338					else 
.LINE 338

	JR	L_90
L_89:
;  339						fastmemcpy(addressto,addressfrom,PAGESIZE);
.LINE 339

	LD	BC,1024
	PUSH	BC
	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFEF)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
L_90:
;  340						//printf("Fake copy to %lx, from %lx, %lx bytes\r\n",addressto, addressfrom, PAGESIZE);
;  341				
;  342					addressto += PAGESIZE;
.LINE 342

	LD	BC,1024
	LD	HL,(IX+%FFFFFFEF)
	ADD	HL,BC
	LD	(IX+%FFFFFFEF),HL
;  343					addressfrom += PAGESIZE;
.LINE 343

	LD	HL,(IX+%FFFFFFF8)
	ADD	HL,BC
	LD	(IX+%FFFFFFF8),HL
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  344				}
L_93:
.LINE 344

	LD	BC,(IX+%FFFFFFF2)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_91
;  345				lockFlashKeyRegister();	// lock the flash before WARM reset
.LINE 345

	CALL	_lockFlashKeyRegister
;  346				printf("\r\n");
.LINE 346

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__71
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  347				
;  348				//Verify correct CRC in flash
;  349				printf("Verifying flash checksum... ");
.LINE 349

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__72
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  350				crcresult = crc32((char*)FLASHSTART, size);
.LINE 350

	LD	BC,(IX+%FFFFFFE9)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFDE),HL
	LD	(IX+%FFFFFFE1),E
;  351	
;  352				if(state == recover) crcexpected = crcbackup;
.LINE 352

	LD	BC,1
	LD	HL,(IX+%FFFFFFF5)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_105
	LD	BC,(IX+%FFFFFFD0)
	LD	A,(IX+%FFFFFFD3)
	LD	(IX+%FFFFFFD4),BC
	LD	(IX+%FFFFFFD7),A
L_105:
;  353				
;  354				if(crcresult == crcexpected)
.LINE 354

	LD	HL,(IX+%FFFFFFDE)
	LD	E,(IX+%FFFFFFE1)
	LD	BC,(IX+%FFFFFFD4)
	LD	A,(IX+%FFFFFFD7)
	CALL	__lcmpu
	JR	NZ,L_104
;  355				{
;  356					printf("- OK\r\n");
.LINE 356

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__75
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  357					state = systemreset;
.LINE 357

	LD	BC,2
	LD	(IX+%FFFFFFF5),BC
;  358				}
;  359				else // CRC Failure - next action depends on current state
.LINE 359

	JR	L_107
L_104:
;  360				{	 // User interaction not possible without MOS handling interrupts
;  361					switch(state)
.LINE 361

	LD	HL,(IX+%FFFFFFF5)
	CALL	__case8D
	JP	(HL)
L__76:
	DW	2
	DB	0
	DW24	L_97	

	DB	1
	DW24	L_98	

	DW24	L_101	

;  362					{
;  363						case firmware:
L_97:
.LINE 363

;  364							printf("\r\nError occured during flash write\r\nAttempting to flash backup firmware...\r\n");
.LINE 364

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__77
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  365							state = recover;
.LINE 365

	LD	BC,1
	LD	(IX+%FFFFFFF5),BC
;  366							break;
.LINE 366

	JR	L_107
;  367						case recover:
L_98:
.LINE 367

;  368							printf("\r\nError occured during flash write\r\nBackup recovery failed\r\n");
.LINE 368

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__78
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  369							while(1); // no more options unfortunately, system needs a firmware programmer
L_100:
.LINE 369

	JR	L_100
;  370						default:
L_101:
.LINE 370

;  371							state = recover;
.LINE 371

	LD	BC,1
	LD	(IX+%FFFFFFF5),BC
	JR	L_107
;  372					}
;  373				}
;  374			}		
;  375		}
;  376		else printf("\n\rUser abort\n\r");
L_109:
.LINE 376

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__79
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  377		
;  378		return 0;
.LINE 378

	XOR	A,A
;  379	}
L_112:
.LINE 379

	LD	SP,IX
	POP	IX
	RET	


;**************************** _update_mos ***************************
;Name                         Addr/Register   Size   Type
;_lockFlashKeyRegister               IMPORT  -----   function
;___print_fmt                        IMPORT     19   variable
;_enableFlashKeyRegister             IMPORT  -----   function
;_reset                              IMPORT  -----   function
;_delayms                            IMPORT  -----   function
;__u_itoa                            IMPORT  -----   function
;_fastmemcpy                         IMPORT  -----   function
;_getch                              IMPORT  -----   function
;_crc32_finalize                     IMPORT  -----   function
;_crc32                              IMPORT  -----   function
;_mos_flseek                         IMPORT  -----   function
;_crc32_initialize                   IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;_mos_fclose                         IMPORT  -----   function
;_getFileSize                        IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;_putch                              IMPORT  -----   function
;crcbackup                            IX-48      4   variable
;crcexpected                          IX-44      4   variable
;filesize                             IX-40      3   variable
;G_0                                  IX-37      3   variable
;crcresult                            IX-34      4   variable
;lastpagebytes                        IX-30      3   variable
;got                                  IX-27      3   variable
;value                                IX-24      1   variable
;size                                 IX-23      3   variable
;ptr                                  IX-20      3   variable
;addressto                            IX-17      3   variable
;pagemax                              IX-14      3   variable
;state                                IX-11      3   variable
;addressfrom                           IX-8      3   variable
;response                              IX-5      1   variable
;file                                  IX-4      1   variable
;counter                               IX-3      3   variable
;filename                              IX+6      3   parameter


; Stack Frame Size: 57 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "update_mos",379,"_update_mos"
	SEGMENT STRSECT
L__44:
	DB	"Error opening \""
	DB	0
L__45:
	DB	"\""
	DB	10,13,0
L__47:
	DB	"Too large for 128KB embedded flash"
	DB	13,10,0
L__49:
	DB	"File does not contain valid MOS ez80 startup code"
	DB	13,10,0
L__50:
	DB	13,10
	DB	"Valid ez80 code"
	DB	13,10
	DB	"Calculating CRC32"
	DB	0
L__53:
	DB	10,13
	DB	"OK"
	DB	10,13,10,13,0
L__54:
	DB	"Erase and program flash (y/n)? "
	DB	0
L__58:
	DB	13,10
	DB	"Backing up existing firmware... "
	DB	0
L__60:
	DB	13,10,0
L__61:
	DB	13
	DB	"Reset in "
	DB	0
L__63:
	DB	13,10
	DB	"Erasing flash... "
	DB	0
L__66:
	DB	13,10
	DB	"Writing new firmware..."
	DB	13,10,0
L__68:
	DB	13
	DB	"Writing flash page "
	DB	0
L__71:
	DB	13,10,0
L__72:
	DB	"Verifying flash checksum... "
	DB	0
L__75:
	DB	"- OK"
	DB	13,10,0
L__77:
	DB	13,10
	DB	"Error occured during flash write"
	DB	13,10
	DB	"Attempting to flash backup firmware..."
	DB	13,10,0
L__78:
	DB	13,10
	DB	"Error occured during flash write"
	DB	13,10
	DB	"Backup recovery failed"
	DB	13,10,0
L__79:
	DB	10,13
	DB	"User abort"
	DB	10,13,0
	SEGMENT CODE
;  380	
;  381	int main(int argc, char * argv[]) {
_main:
.DEFINE "_main"

.VALUE _main

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "main",381,"_main"

.LINE 381

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  382	
;  383		if(argc != 3) {
.LINE 383

	LD	BC,3
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_118
;  384			usage();
.LINE 384

	CALL	_usage
;  385			return 0;
.LINE 385

	OR	A,A
	SBC	HL,HL
	JR	L_119
;  386		}
L_118:
.LINE 386

;  387	
;  388		if(memcmp(argv[1], "mos", 3) == 0) {
.LINE 388

	PUSH	BC
	LD	BC,L__82
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_117
;  389			return update_mos(argv[2]);
.LINE 389

	LD	IY,(IX+%9)
	LEA	HL,IY+%6
	LD	BC,(HL)
	PUSH	BC
	CALL	_update_mos
	POP	BC
	UEXT	HL
	LD	L,A
	JR	L_119
;  390		}
;  391		else {
L_117:
.LINE 391

;  392			if(memcmp(argv[1], "vdp", 3) == 0) {
.LINE 392

	LD	BC,3
	PUSH	BC
	LD	BC,L__84
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_115
;  393				return update_vdp(argv[2]);
.LINE 393

	LD	IY,(IX+%9)
	LEA	HL,IY+%6
	LD	BC,(HL)
	PUSH	BC
	CALL	_update_vdp
	POP	BC
	UEXT	HL
	LD	L,A
	JR	L_119
;  394			}
;  395			else {
L_115:
.LINE 395

;  396				usage();
.LINE 396

	CALL	_usage
;  397				return 0;
.LINE 397

	OR	A,A
	SBC	HL,HL
;  398			}
;  399		}
;  400	}
L_119:
.LINE 400

	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_memcmp                             IMPORT  -----   function
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "main",400,"_main"
	SEGMENT STRSECT
L__82:
	DB	"mos"
	DB	0
L__84:
	DB	"vdp"
	DB	0
	XREF _memcmp:ROM
	XREF _getFileSize:ROM
	XREF _crc32_finalize:ROM
	XREF _crc32_initialize:ROM
	XREF _crc32:ROM
	XREF _delayms:ROM
	XREF _startVDPupdate:ROM
	XREF _reset:ROM
	XREF _fastmemcpy:ROM
	XREF _lockFlashKeyRegister:ROM
	XREF _enableFlashKeyRegister:ROM
	XREF _mos_flseek:ROM
	XREF _mos_fread:ROM
	XREF _mos_fclose:ROM
	XREF _mos_fopen:ROM
	XREF _getsysvar_scrchar:ROM
	XREF _getch:ROM
	XREF __u_ultoa:ROM
	XREF __u_itoa:ROM
	XREF ___print_sendstring:ROM
	XREF ___print_xputch:ROM
	XREF ___print_uputch:ROM
	XREF ___print_fmt:ROM
	XREF __lcmpu:ROM
	XREF __iand:ROM
	XREF __stoiu:ROM
	XREF __icmpzero:ROM
	XREF __case8D:ROM
	XREF __ishru_b:ROM
	XREF __ishrs_b:ROM
	XDEF _main
	XDEF _update_mos
	XDEF _update_vdp
	XDEF _getResponse
	XDEF _usage
	XDEF _print_version
	XDEF _containsESP32Header
	XDEF _esp32_magicnumbers
	XDEF _containsMosHeader
	XDEF _mos_magicnumbers
	XDEF _vdp_ota_present
	XDEF _getCharAt
	XDEF _putch
	XDEF _errno
	END
