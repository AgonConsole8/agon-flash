; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\main.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",51
.DEFINE "clock"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "vpd_protocol_flags"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "keyascii"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "keymods"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cursorX"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cursorY"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrchar"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrpixel"
.VALUE 10
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "audioChannel"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "audioSuccess"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrwidth"
.VALUE 15
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "scrheight"
.VALUE 17
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "scrcols"
.VALUE 19
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrrows"
.VALUE 20
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrcolours"
.VALUE 21
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrpixelIndex"
.VALUE 22
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "keycode"
.VALUE 23
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "keydown"
.VALUE 24
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "keycount"
.VALUE 25
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rtc"
.VALUE 26
.CLASS 8
.DIM 6
.TYPE 108
.ENDEF
.DEFINE "rtc_spare"
.VALUE 32
.CLASS 8
.DIM 2
.TYPE 108
.ENDEF
.DEFINE "keydelay"
.VALUE 34
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "keyrate"
.VALUE 36
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "keyled"
.VALUE 38
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrmode"
.VALUE 39
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rtc_enable"
.VALUE 40
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "mouseX"
.VALUE 41
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "mouseY"
.VALUE 43
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "mouseButtons"
.VALUE 45
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "mouseWheel"
.VALUE 46
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "mouseXDelta"
.VALUE 47
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "mouseYDelta"
.VALUE 49
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",8
.DEFINE "baudRate"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "dataBits"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stopBits"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "parity"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flowcontrol"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "eir"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",15
.DEFINE "fs"
.VALUE 0
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "id"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "attr"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stat"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "sclust"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "objsize"
.VALUE 11
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",36
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME5"
.TYPE 8
.ENDEF
.DEFINE "flag"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "err"
.VALUE 16
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fptr"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_sect"
.VALUE 29
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_ptr"
.VALUE 33
.CLASS 8
.TYPE 46
.ENDEF
.ENDREC "NONAME6"
	SEGMENT BSS
_errno:
	DS	3
.DEFINE "errno"
.ALIAS "_errno"
.CLASS 83
.VALUE _errno
.TYPE 4
.ENDEF
;    1	/*
;    2	 * Title:			Agon firmware upgrade utility
;    3	 * Author:			Jeroen Venema
;    4	 * Created:			17/12/2022
;    5	 * Last Updated:	14/10/2023
;    6	 * 
;    7	 * Modinfo:
;    8	 * 17/12/2022:		Initial version
;    9	 * 05/04/2022:		Changed timer to 5sec at reset.
;   10	 *                  Sends cls just before reset
;   11	 * 07/06/2023:		Included faster crc32, by Leigh Brown
;   12	 * 14/10/2023:		VDP update code, MOS update rewritten for simplicity
;   13	 */
;   14	
;   15	#include <ez80.h>
;   16	#include <stdio.h>
;   17	#include <stdlib.h>
;   18	#include <ERRNO.H>
;   19	#include <ctype.h>
;   20	#include "mos-interface.h"
;   21	#include "flash.h"
;   22	#include "agontimer.h"
;   23	#include "crc32.h"
;   24	#include "filesize.h"
;   25	#include "./stdint.h"
;   26	#include <string.h>
;   27	
;   28	#define UNLOCKMATCHLENGTH 9
;   29	#define EXIT_FILENOTFOUND	4
;   30	#define EXIT_INVALIDPARAMETER	19
;   31	#define DEFAULT_MOSFIRMWARE	"MOS.bin"
;   32	#define DEFAULT_VDPFIRMWARE	"firmware.bin"
;   33	
;   34	#define CMDUNKNOWN	0
;   35	#define CMDALL		1
;   36	#define CMDMOS		2
;   37	#define CMDVDP		3
;   38	
;   39	int errno; // needed by standard library
	SEGMENT CODE
;   40	enum states{firmware,retry,systemreset};
;   41	
;   42	// separate putch function that doesn't rely on a running MOS firmware
;   43	// UART0 initialization done by MOS firmware previously
;   44	// This utility doesn't run without MOS to load it anyway
;   45	int putch(int c)
;   46	{
_putch:
.DEFINE "_putch"

.VALUE _putch

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "putch",46,"_putch"

.LINE 46

.DEFINE "c"

.CLASS 65

.VALUE 6

.TYPE 4

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
.ENDEF

;   47		UINT8 lsr,temt;
;   48		
;   49		while((UART0_LSR & 0x40) == 0);
L_1:
.LINE 49

	IN0	A,(197)
	AND	A,%40
	UEXT	HL
	LD	L,A
	CALL	__icmpzero
	JR	Z,L_1
;   50		UART0_THR = c;
.LINE 50

	LD	A,(IX+%6)
	OUT0	(192),A
;   51		return c;
.LINE 51

	LD	HL,(IX+%6)
;   52	}
.LINE 52

	LD	SP,IX
	POP	IX
	RET	


;**************************** _putch ***************************
;Name                         Addr/Register   Size   Type
;c                                     IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "putch",52,"_putch"
;   53	
;   54	void beep(unsigned int number) {
_beep:
.DEFINE "_beep"

.VALUE _beep

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "beep",54,"_beep"

.LINE 54

.DEFINE "number"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   55		while(number--) {
.LINE 55

	JR	L_5
L_6:
;   56			putch(7);
.LINE 56

	LD	BC,7
	PUSH	BC
	CALL	_putch
	POP	BC
;   57			delayms(250);
.LINE 57

	LD	BC,250
	PUSH	BC
	CALL	_delayms
	POP	BC
;   58		}
L_5:
.LINE 58

	LD	HL,(IX+%6)
	LD	IY,(IX+%6)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%6),IY
	CALL	__icmpzero
	JR	NZ,L_6
;   59	}
.LINE 59

	LD	SP,IX
	POP	IX
	RET	


;**************************** _beep ***************************
;Name                         Addr/Register   Size   Type
;_delayms                            IMPORT  -----   function
;_putch                              IMPORT  -----   function
;number                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "beep",59,"_beep"
;   60	
;   61	uint8_t getCharAt(uint16_t x, uint16_t y) {
_getCharAt:
.DEFINE "_getCharAt"

.VALUE _getCharAt

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "getCharAt",61,"_getCharAt"

.LINE 61

.DEFINE "x"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

.DEFINE "sysvars"

.CLASS 65

.VALUE -3

.TAG "NONAME3"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;   62		sysvar_t *sysvars = getsysvars();
.LINE 62

	CALL	_getsysvars
	LD	(IX+%FFFFFFFD),HL
;   63		delayms(20);
.LINE 63

	LD	BC,20
	PUSH	BC
	CALL	_delayms
	POP	BC
;   64		putch(23);
.LINE 64

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;   65		putch(0);
.LINE 65

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;   66		putch(131);
.LINE 66

	LD	BC,131
	PUSH	BC
	CALL	_putch
	POP	BC
;   67		putch(x & 0xFF);
.LINE 67

	LD	BC,(IX+%6)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   68		putch((x >> 8) & 0xFF);
.LINE 68

	LD	BC,(IX+%6)
	CALL	__stoiu
	LD	A,%8
	CALL	__ishrs_b
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   69		putch(y & 0xFF);
.LINE 69

	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   70		putch((y >> 8) & 0xFF);
.LINE 70

	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	A,%8
	CALL	__ishrs_b
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   71		delayms(100);
.LINE 71

	LD	BC,100
	PUSH	BC
	CALL	_delayms
	POP	BC
;   72		return sysvars->scrchar;
.LINE 72

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%9)
;   73	}
.LINE 73

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getCharAt ***************************
;Name                         Addr/Register   Size   Type
;_putch                              IMPORT  -----   function
;_delayms                            IMPORT  -----   function
;_getsysvars                         IMPORT  -----   function
;sysvars                               IX-3      3   variable
;y                                     IX+9      2   parameter
;x                                     IX+6      2   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getCharAt",73,"_getCharAt"
;   74	
;   75	bool vdp_ota_present(void) {
_vdp_ota_present:
.DEFINE "_vdp_ota_present"

.VALUE _vdp_ota_present

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "vdp_ota_present",75,"_vdp_ota_present"

.LINE 75

.DEFINE "n"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "test"

.CLASS 65

.VALUE -11

.DIM 9

.TYPE 98

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF5
	LD	SP,HL
;   76		char test[UNLOCKMATCHLENGTH];
;   77		uint16_t n;
;   78	
;   79		putch(23);
.LINE 79

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;   80		putch(0);
.LINE 80

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;   81		putch(0xA1);
.LINE 81

	LD	BC,161
	PUSH	BC
	CALL	_putch
	POP	BC
;   82		putch(0);
.LINE 82

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;   83		printf("unlock");
.LINE 83

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__5
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   84	
;   85		for(n = 0; n < UNLOCKMATCHLENGTH+1; n++) test[n] = getCharAt(n+8, 3);
.LINE 85

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_12
L_10:
	LD	BC,3
	PUSH	BC
	LD	IY,(IX+%FFFFFFFE)
	LEA	BC,IY+%8
	PUSH	BC
	CALL	_getCharAt
	POP	BC
	POP	BC
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,HL
	LEA	HL,IX+%FFFFFFF5
	ADD	HL,BC
	LD	(HL),A
	LD	HL,(IX+%FFFFFFFE)
	INC	HL
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
L_12:
	LD.LIS	BC,10
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_10
;   86		// 3 - line on-screen
;   87		if(memcmp(test, "unlocked!",UNLOCKMATCHLENGTH) == 0) return true;
.LINE 87

	LD	BC,9
	PUSH	BC
	LD	BC,L__7
	PUSH	BC
	PEA	IX+%FFFFFFF5
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_14
	LD	A,%1
	JR	L_16
;   88		else return false;
L_14:
.LINE 88

	XOR	A,A
;   89	}
L_16:
.LINE 89

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vdp_ota_present ***************************
;Name                         Addr/Register   Size   Type
;_memcmp                             IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_putch                              IMPORT  -----   function
;test                                 IX-11      9   variable
;n                                     IX-2      2   variable


; Stack Frame Size: 17 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vdp_ota_present",89,"_vdp_ota_present"
	SEGMENT STRSECT
L__5:
	DB	"unlock"
	DB	0
L__7:
	DB	"unlocked!"
	DB	0
	SEGMENT DATA
_mos_magicnumbers:
	DB	243
	DB	237
	DB	125
	DB	91
	DB	195
.DEFINE "mos_magicnumbers"
.ALIAS "_mos_magicnumbers"
.CLASS 69
.VALUE _mos_magicnumbers
.DIM 5
.TYPE 108
.ENDEF
;   90	
;   91	uint8_t mos_magicnumbers[] = {0xF3, 0xED, 0x7D, 0x5B, 0xC3};
	SEGMENT CODE
;   92	#define MOS_MAGICLENGTH 5
;   93	bool containsMosHeader(uint8_t *filestart) {
_containsMosHeader:
.DEFINE "_containsMosHeader"

.VALUE _containsMosHeader

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "containsMosHeader",93,"_containsMosHeader"

.LINE 93

.DEFINE "filestart"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "match"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;   94		uint8_t n;
;   95		bool match = true;
.LINE 95

	LD	(IX+%FFFFFFFE),%1
;   96	
;   97		for(n = 0; n < MOS_MAGICLENGTH; n++) if(mos_magicnumbers[n] != filestart[n]) match = false;
.LINE 97

	LD	(IX+%FFFFFFFF),%0
	JR	L_21
L_19:
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,_mos_magicnumbers
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_20
	LD	(IX+%FFFFFFFE),%0
L_20:
	INC	(IX+%FFFFFFFF)
L_21:
	LD	A,(IX+%FFFFFFFF)
	CP	A,%5
	JR	C,L_19
;   98		return match;
.LINE 98

	LD	A,(IX+%FFFFFFFE)
;   99	}
.LINE 99

	LD	SP,IX
	POP	IX
	RET	


;**************************** _containsMosHeader ***************************
;Name                         Addr/Register   Size   Type
;_mos_magicnumbers                   STATIC      5   variable
;match                                 IX-2      1   variable
;n                                     IX-1      1   variable
;filestart                             IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "containsMosHeader",99,"_containsMosHeader"
	SEGMENT DATA
_esp32_magicnumbers:
	DB	50
	DB	84
	DB	205
	DB	171
.DEFINE "esp32_magicnumbers"
.ALIAS "_esp32_magicnumbers"
.CLASS 69
.VALUE _esp32_magicnumbers
.DIM 4
.TYPE 108
.ENDEF
;  100	
;  101	uint8_t esp32_magicnumbers[] = {0x32, 0x54, 0xCD, 0xAB};
	SEGMENT CODE
;  102	#define ESP32_MAGICLENGTH 4
;  103	#define ESP32_MAGICSTART 0x20
;  104	bool containsESP32Header(uint8_t *filestart) {
_containsESP32Header:
.DEFINE "_containsESP32Header"

.VALUE _containsESP32Header

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "containsESP32Header",104,"_containsESP32Header"

.LINE 104

.DEFINE "filestart"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "match"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  105		uint8_t n;
;  106		bool match = true;
.LINE 106

	LD	(IX+%FFFFFFFE),%1
;  107	
;  108		filestart += ESP32_MAGICSTART; // start of ESP32 magic header
.LINE 108

	LD	IY,(IX+%6)
	LEA	IY,IY+%20
	LD	(IX+%6),IY
;  109		for(n = 0; n < ESP32_MAGICLENGTH; n++) {
.LINE 109

	LD	(IX+%FFFFFFFF),%0
	JR	L_28
L_26:
;  110			if(esp32_magicnumbers[n] != filestart[n]) match = false;
.LINE 110

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,_esp32_magicnumbers
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_27
	LD	(IX+%FFFFFFFE),%0
;  111		}
L_27:
.LINE 111

	INC	(IX+%FFFFFFFF)
L_28:
	LD	A,(IX+%FFFFFFFF)
	CP	A,%4
	JR	C,L_26
;  112		return match;
.LINE 112

	LD	A,(IX+%FFFFFFFE)
;  113	}
.LINE 113

	LD	SP,IX
	POP	IX
	RET	


;**************************** _containsESP32Header ***************************
;Name                         Addr/Register   Size   Type
;_esp32_magicnumbers                 STATIC      4   variable
;match                                 IX-2      1   variable
;n                                     IX-1      1   variable
;filestart                             IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "containsESP32Header",113,"_containsESP32Header"
;  114	
;  115	void print_version(void) {
_print_version:
.DEFINE "_print_version"

.VALUE _print_version

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "print_version",115,"_print_version"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  116		printf("Agon firmware upgrade utility v1.6\n\r\n\r");
.LINE 116

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__16
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  117	}
.LINE 117

	LD	SP,IX
	POP	IX
	RET	


;**************************** _print_version ***************************
;Name                         Addr/Register   Size   Type
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "print_version",117,"_print_version"
	SEGMENT STRSECT
L__16:
	DB	"Agon firmware upgrade utility v1.6"
	DB	10,13,10,13,0
	SEGMENT CODE
;  118	
;  119	void usage(void) {
_usage:
.DEFINE "_usage"

.VALUE _usage

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "usage",119,"_usage"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  120		print_version();
.LINE 120

	CALL	_print_version
;  121		printf("Usage: FLASH [full | [mos <filename>] [vdp <filename>]] <-s|-silent>\n\r");
.LINE 121

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__18
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  122	}
.LINE 122

	LD	SP,IX
	POP	IX
	RET	


;**************************** _usage ***************************
;Name                         Addr/Register   Size   Type
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "usage",122,"_usage"
	SEGMENT STRSECT
L__18:
	DB	"Usage: FLASH [full | [mos <filename>] [vdp <filename>]] <-s|-silent>"
	DB	10,13,0
	SEGMENT CODE
;  123	
;  124	typedef enum {
;  125		MOS,
;  126		VDP
;  127	} flashtype;
;  128	
;  129	bool getResponse(flashtype t, uint32_t crc) {
_getResponse:
.DEFINE "_getResponse"

.VALUE _getResponse

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "getResponse",129,"_getResponse"

.LINE 129

.DEFINE "t"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "crc"

.CLASS 65

.VALUE 9

.TYPE 15

.ENDEF

.DEFINE "response"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;  130		uint8_t response = 0;
.LINE 130

	LD	(IX+%FFFFFFFF),%0
;  131	
;  132		switch(t) {
.LINE 132

	LD	HL,(IX+%6)
	CALL	__case8D
	JP	(HL)
L__20:
	DW	2
	DB	0
	DW24	L_33	

	DB	1
	DW24	L_34	

	DW24	L_36	

;  133			case MOS:
L_33:
.LINE 133

;  134				printf("\r\n\r\n0x%04lX - flash to MOS (y/n)?", crc);
.LINE 134

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__21
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%4
	LD	(___print_fmt+5),A
	LD	A,%60
	LD	(___print_fmt+1),A
	LD	A,%78
	LD	(___print_fmt+4),A
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	__u_ultoa
	POP	BC
	POP	BC
	LD	BC,L__22
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  135				break;
.LINE 135

	JR	L_36
;  136			case VDP:
L_34:
.LINE 136

;  137				printf("\r\n\r\n0x%04lX - flash to VDP (y/n)?", crc);
.LINE 137

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__23
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%4
	LD	(___print_fmt+5),A
	LD	A,%60
	LD	(___print_fmt+1),A
	LD	A,%78
	LD	(___print_fmt+4),A
	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	__u_ultoa
	POP	BC
	POP	BC
	LD	BC,L__24
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  138				break;
.LINE 138

	JR	L_36
;  139		}
;  140	
;  141		while((response != 'y') && (response != 'n')) response = tolower(getch());
L_37:
.LINE 141

	CALL	_getch
	LD	B,A
	LD	A,B
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	LD	(IX+%FFFFFFFF),L
L_36:
	LD	A,(IX+%FFFFFFFF)
	CP	A,%79
	JR	Z,L_41
	LD	A,(IX+%FFFFFFFF)
	CP	A,%6E
	JR	NZ,L_37
L_41:
;  142		if(response == 'n') printf("\r\nUser abort\n\r\n\r");
.LINE 142

	LD	A,(IX+%FFFFFFFF)
	CP	A,%6E
	JR	NZ,L_40
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__28
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  143		else printf("\r\n\r\n");
.LINE 143

	JR	L_42
L_40:
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__29
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
L_42:
;  144		return response == 'y';
.LINE 144

	LD	A,(IX+%FFFFFFFF)
	CP	A,%79
	JR	NZ,L__31
	LD	A,%1
	JR	L__32
L__31:
	XOR	A,A
L__32:
;  145	}
.LINE 145

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getResponse ***************************
;Name                         Addr/Register   Size   Type
;_getch                              IMPORT  -----   function
;_tolower                            IMPORT  -----   function
;__u_ultoa                           IMPORT  -----   function
;___print_fmt                        IMPORT     19   variable
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;response                              IX-1      1   variable
;crc                                   IX+9      4   parameter
;t                                     IX+6      3   parameter


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getResponse",145,"_getResponse"
	SEGMENT STRSECT
L__21:
	DB	13,10,13,10
	DB	"0x"
	DB	0
L__22:
	DB	" - flash to MOS (y/n)?"
	DB	0
L__23:
	DB	13,10,13,10
	DB	"0x"
	DB	0
L__24:
	DB	" - flash to VDP (y/n)?"
	DB	0
L__28:
	DB	13,10
	DB	"User abort"
	DB	10,13,10,13,0
L__29:
	DB	13,10,13,10,0
	SEGMENT CODE
;  146	
;  147	uint8_t update_vdp(char *filename) {
_update_vdp:
.DEFINE "_update_vdp"

.VALUE _update_vdp

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "update_vdp",147,"_update_vdp"

.LINE 147

.DEFINE "filename"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "filesize"

.CLASS 65

.VALUE -4

.TYPE 14

.ENDEF

.DEFINE "buffer"

.CLASS 65

.VALUE -40

.DIM 36

.TYPE 108

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFD8
	LD	SP,HL
;  148		uint8_t file;
;  149		uint8_t buffer[ESP32_MAGICLENGTH + ESP32_MAGICSTART];
;  150		uint24_t filesize;
;  151		//uint32_t crcresult;
;  152		uint24_t size, n;
;  153		uint8_t response;
;  154	
;  155		putch(12); // cls
.LINE 155

	LD	BC,12
	PUSH	BC
	CALL	_putch
	POP	BC
;  156		print_version();	
.LINE 156

	CALL	_print_version
;  157		printf("Unlocking VDP updater...\r\n");
.LINE 157

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__34
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  158		
;  159		if(!vdp_ota_present()) {
.LINE 159

	CALL	_vdp_ota_present
	OR	A,A
	JR	NZ,L_45
;  160			printf(" failed - incompatible VDP\r\n");
.LINE 160

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__36
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  161			beep(5);
.LINE 161

	LD	BC,5
	PUSH	BC
	CALL	_beep
	POP	BC
;  162			return 0;
.LINE 162

	XOR	A,A
	JR	L_50
;  163		}
L_45:
.LINE 163

;  164		//vdp_ota_present();
;  165	
;  166		file = mos_fopen(filename, fa_read);
.LINE 166

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  167		if(!file) {
.LINE 167

	OR	A,A
	JR	NZ,L_47
;  168			printf("Error opening \"%s\"\n\r",filename);
.LINE 168

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__38
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__39
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  169			return EXIT_FILENOTFOUND;
.LINE 169

	LD	A,%4
	JR	L_50
;  170		}
L_47:
.LINE 170

;  171	
;  172		mos_fread(file, (char *)buffer, ESP32_MAGICLENGTH + ESP32_MAGICSTART);
.LINE 172

	LD	BC,36
	PUSH	BC
	PEA	IX+%FFFFFFD8
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  173		if(!containsESP32Header(buffer)) {
.LINE 173

	PEA	IX+%FFFFFFD8
	CALL	_containsESP32Header
	POP	BC
	OR	A,A
	JR	NZ,L_49
;  174			printf("File does not contain valid ESP32 code\r\n");
.LINE 174

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__41
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  175			mos_fclose(file);
.LINE 175

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  176			return EXIT_INVALIDPARAMETER;
.LINE 176

	LD	A,%13
	JR	L_50
;  177		}
L_49:
.LINE 177

;  178		//printf("\r\nValid ESP32 code\r\nCalculating CRC32");
;  179		printf("\r\nValid ESP32 code\r\n");
.LINE 179

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__42
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  180		//crc32_initialize();
;  181		//mos_flseek(file, 0);
;  182		//while(1) {
;  183		//	size = mos_fread(file, (char *)BUFFER1, BLOCKSIZE);
;  184		//	if(size == 0) break;
;  185		//	putch('.');
;  186			//crc32((char *)BUFFER1, size);
;  187		//}
;  188		//crcresult = crc32_finalize();
;  189	
;  190		// Do actual work here
;  191		mos_flseek(file, 0); // reset to zero, because we read part of the header already
.LINE 191

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  192		printf("Updating VDP firmware\r\n");
.LINE 192

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__43
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  193		filesize = getFileSize(file);	
.LINE 193

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_getFileSize
	POP	BC
	LD	(IX+%FFFFFFFC),HL
;  194		startVDPupdate(file, filesize);
.LINE 194

	LD	BC,HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_startVDPupdate
	POP	BC
	POP	BC
;  195		mos_fclose(file);
.LINE 195

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  196		//reset();
;  197		return 0; // will never return, but let's give the compiler a break
.LINE 197

	XOR	A,A
;  198	}
L_50:
.LINE 198

	LD	SP,IX
	POP	IX
	RET	


;**************************** _update_vdp ***************************
;Name                         Addr/Register   Size   Type
;_startVDPupdate                     IMPORT  -----   function
;_getFileSize                        IMPORT  -----   function
;_mos_flseek                         IMPORT  -----   function
;_mos_fclose                         IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_putch                              IMPORT  -----   function
;buffer                               IX-40     36   variable
;filesize                              IX-4      3   variable
;file                                  IX-1      1   variable
;filename                              IX+6      3   parameter


; Stack Frame Size: 49 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "update_vdp",198,"_update_vdp"
	SEGMENT STRSECT
L__34:
	DB	"Unlocking VDP updater..."
	DB	13,10,0
L__36:
	DB	" failed - incompatible VDP"
	DB	13,10,0
L__38:
	DB	"Error opening \""
	DB	0
L__39:
	DB	"\""
	DB	10,13,0
L__41:
	DB	"File does not contain valid ESP32 code"
	DB	13,10,0
L__42:
	DB	13,10
	DB	"Valid ESP32 code"
	DB	13,10,0
L__43:
	DB	"Updating VDP firmware"
	DB	13,10,0
	SEGMENT CODE
;  199	
;  200	uint8_t update_mos(char *filename) {
_update_mos:
.DEFINE "_update_mos"

.VALUE _update_mos

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "update_mos",200,"_update_mos"

.LINE 200

.DEFINE "filename"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "counter"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "addressfrom"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

.DEFINE "pagemax"

.CLASS 65

.VALUE -10

.TYPE 14

.ENDEF

.DEFINE "state"

.CLASS 65

.VALUE -13

.TYPE 4

.ENDEF

.DEFINE "filesize"

.CLASS 65

.VALUE -16

.TYPE 14

.ENDEF

.DEFINE "addressto"

.CLASS 65

.VALUE -19

.TYPE 14

.ENDEF

.DEFINE "ptr"

.CLASS 65

.VALUE -22

.TYPE 34

.ENDEF

.DEFINE "got"

.CLASS 65

.VALUE -25

.TYPE 14

.ENDEF

.DEFINE "value"

.CLASS 65

.VALUE -26

.TYPE 12

.ENDEF

.DEFINE "crcresult"

.CLASS 65

.VALUE -30

.TYPE 15

.ENDEF

.DEFINE "lastpagebytes"

.CLASS 65

.VALUE -33

.TYPE 14

.ENDEF

.DEFINE "size"

.CLASS 65

.VALUE -39

.TYPE 14

.ENDEF

.DEFINE "crcexpected"

.CLASS 65

.VALUE -43

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFD5
	LD	SP,HL
;  201		uint32_t crcexpected,crcresult;
;  202		uint24_t size = 0;
.LINE 202

	LD	BC,0
	LD	(IX+%FFFFFFD9),BC
;  203		uint24_t got;
;  204		uint8_t file;
;  205		char* ptr = (char*)BUFFER1;
.LINE 205

	LD	BC,327680
	LD	(IX+%FFFFFFEA),BC
;  206		uint8_t value;
;  207		uint24_t counter,pagemax, lastpagebytes;
;  208		uint24_t addressto,addressfrom;
;  209		enum states state;
;  210		uint24_t filesize;
;  211	
;  212		putch(12); // cls
.LINE 212

	LD	BC,12
	PUSH	BC
	CALL	_putch
	POP	BC
;  213		print_version();	
.LINE 213

	CALL	_print_version
;  214		
;  215		file = mos_fopen(filename, fa_read);
.LINE 215

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),A
;  216		if(!file)
.LINE 216

	OR	A,A
	JR	NZ,L_52
;  217		{
;  218			printf("Error opening \"%s\"\n\r",filename);
.LINE 218

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__46
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__47
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  219			return EXIT_FILENOTFOUND;
.LINE 219

	LD	A,%4
	JR	L_93
;  220		}
L_52:
.LINE 220

;  221	
;  222		mos_fread(file, (char *)BUFFER1, MOS_MAGICLENGTH);
.LINE 222

	LD	BC,5
	PUSH	BC
	LD	BC,327680
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  223		if(!containsMosHeader((uint8_t *)BUFFER1)) {
.LINE 223

	LD	BC,327680
	PUSH	BC
	CALL	_containsMosHeader
	POP	BC
	OR	A,A
	JR	NZ,L_54
;  224			printf("File does not contain valid MOS ez80 startup code\r\n");
.LINE 224

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__49
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  225			mos_fclose(file);
.LINE 225

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  226			return EXIT_INVALIDPARAMETER;
.LINE 226

	LD	A,%13
	JR	L_93
;  227		}
L_54:
.LINE 227

;  228	
;  229		filesize = getFileSize(file);
.LINE 229

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_getFileSize
	POP	BC
	LD	(IX+%FFFFFFF0),HL
;  230		if(filesize > FLASHSIZE) {
.LINE 230

	LD	BC,HL
	LD	HL,131072
	OR	A,A
	SBC	HL,BC
	JR	NC,L_56
;  231			printf("File too large for 128KB embedded flash\r\n");
.LINE 231

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__51
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  232			mos_fclose(file);
.LINE 232

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  233			return EXIT_INVALIDPARAMETER;
.LINE 233

	LD	A,%13
	JR	L_93
;  234		}
L_56:
.LINE 234

;  235	
;  236		printf("\r\nValid ez80 code\r\nCalculating CRC32");
.LINE 236

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__52
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  237	
;  238		crc32_initialize();
.LINE 238

	CALL	_crc32_initialize
;  239		mos_flseek(file, 0);
.LINE 239

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  240		
;  241		// Read file to memory
;  242		while((got = mos_fread(file, ptr, BLOCKSIZE)) > 0) {
.LINE 242

	JR	L_57
L_58:
;  243			crc32(ptr, got);
.LINE 243

	LD	BC,(IX+%FFFFFFE7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFEA)
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
;  244			ptr += got;
.LINE 244

	LD	BC,(IX+%FFFFFFE7)
	LD	HL,(IX+%FFFFFFEA)
	ADD	HL,BC
	LD	(IX+%FFFFFFEA),HL
;  245			putch('.');
.LINE 245

	LD	BC,46
	PUSH	BC
	CALL	_putch
	POP	BC
;  246		}		
L_57:
.LINE 246

	LD	BC,16384
	PUSH	BC
	LD	BC,(IX+%FFFFFFEA)
	PUSH	BC
	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE7),HL
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	C,L_58
;  247		crcresult = crc32_finalize();
.LINE 247

	CALL	_crc32_finalize
	LD	(IX+%FFFFFFE2),HL
	LD	(IX+%FFFFFFE5),E
;  248		// Actual work here	
;  249		di();								// prohibit any access to the old MOS firmware
.LINE 249

	di
;  250	
;  251		// start address in flash
;  252		addressto = FLASHSTART;
.LINE 252

	LD	BC,0
	LD	(IX+%FFFFFFED),BC
;  253		addressfrom = BUFFER1;
.LINE 253

	LD	BC,327680
	LD	(IX+%FFFFFFF9),BC
;  254		
;  255		crcexpected = crcresult;
.LINE 255

	LD	BC,(IX+%FFFFFFE2)
	LD	A,(IX+%FFFFFFE5)
	LD	(IX+%FFFFFFD5),BC
	LD	(IX+%FFFFFFD8),A
;  256		state = firmware;
.LINE 256

	LD	BC,0
	LD	(IX+%FFFFFFF3),BC
;  257		size = filesize;	
.LINE 257

	LD	BC,(IX+%FFFFFFF0)
	LD	(IX+%FFFFFFD9),BC
;  258		while(1)
L_91:
.LINE 258

;  259		{
;  260			switch(state)
.LINE 260

	LD	HL,(IX+%FFFFFFF3)
	CALL	__case8D
	JP	(HL)
L__54:
	DW	2
	DB	0
	DW24	L_60	

	DB	1
	DW24	L_61	

	DW24	L_62	

;  261			{
;  262				case firmware:
L_60:
.LINE 262

;  263					// start address in flash
;  264					addressfrom = BUFFER1;
.LINE 264

	LD	BC,327680
	LD	(IX+%FFFFFFF9),BC
;  265					crc32_initialize();
.LINE 265

	CALL	_crc32_initialize
;  266					break;
.LINE 266

	JR	L_63
;  267				case retry:
L_61:
.LINE 267

;  268					// start address in flash
;  269					addressfrom = BUFFER1;
.LINE 269

	LD	BC,327680
	LD	(IX+%FFFFFFF9),BC
;  270					crc32_initialize();
.LINE 270

	CALL	_crc32_initialize
;  271					break;
.LINE 271

	JR	L_63
;  272				default:
L_62:
.LINE 272

;  273					// RESET SYSTEM
;  274					printf("\r\n");
.LINE 274

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__55
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  275					printf("Done\r\n");
.LINE 275

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__56
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  276					//printf("Press reset button");
;  277					//while(1); // force cold boot for the user, so VDP will reset optimally
;  278					return 0;
.LINE 278

	XOR	A,A
	JR	L_93
;  279			}
L_63:
.LINE 279

;  280	
;  281			// Unprotect and erase flash
;  282			printf("Erasing flash... ");
.LINE 282

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__57
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  283			enableFlashKeyRegister();	// unlock Flash Key Register, so we can write to the Flash Write/Erase protection registers
.LINE 283

	CALL	_enableFlashKeyRegister
;  284			FLASH_PROT = 0;				// disable protection on all 8x16KB blocks in the flash
.LINE 284

	XOR	A,A
	OUT0	(250),A
;  285			enableFlashKeyRegister();	// will need to unlock again after previous write to the flash protection register
.LINE 285

	CALL	_enableFlashKeyRegister
;  286			FLASH_FDIV = 0x5F;			// Ceiling(18Mhz * 5,1us) = 95, or 0x5F
.LINE 286

	LD	A,%5F
	OUT0	(249),A
;  287			
;  288			for(counter = 0; counter < FLASHPAGES; counter++)
.LINE 288

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_69
L_67:
;  289			{
;  290				FLASH_PAGE = counter;
.LINE 290

	LD	A,(IX+%FFFFFFFD)
	OUT0	(252),A
;  291				FLASH_PGCTL = 0x02;			// Page erase bit enable, start erase
.LINE 291

	LD	A,%2
	OUT0	(255),A
;  292	
;  293				do
L_65:
.LINE 293

;  294				{
;  295					value = FLASH_PGCTL;
.LINE 295

	IN0	A,(255)
	LD	(IX+%FFFFFFE6),A
;  296				}
;  297				while(value & 0x02);// wait for completion of erase			
.LINE 297

	AND	A,%2
	JR	NZ,L_65
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  298			}
L_69:
.LINE 298

	LD	BC,128
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_67
;  299			
;  300			printf("\r\nWriting new firmware...\r\n");
.LINE 300

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__60
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  301			
;  302			// determine number of pages to write
;  303			pagemax = size/PAGESIZE;
.LINE 303

	LD	HL,(IX+%FFFFFFF0)
	LD	A,%A
	CALL	__ishru_b
	LD	(IX+%FFFFFFF6),HL
;  304			if(size%PAGESIZE) // last page has less than PAGESIZE bytes
.LINE 304

	LD	BC,1023
	LD	HL,(IX+%FFFFFFF0)
	CALL	__iand
	LD	(IX+%FFFFFFDC),HL
	CALL	__icmpzero
	JR	Z,L_72
;  305			{
;  306				pagemax += 1;
.LINE 306

	LD	BC,(IX+%FFFFFFF6)
	INC	BC
	LD	(IX+%FFFFFFF6),BC
;  307				lastpagebytes = size%PAGESIZE;			
.LINE 307

	LD	BC,(IX+%FFFFFFDC)
	LD	(IX+%FFFFFFDF),BC
;  308			}
;  309			else lastpagebytes = PAGESIZE; // normal last page
.LINE 309

	JR	L_80
L_72:
	LD	BC,1024
	LD	(IX+%FFFFFFDF),BC
L_80:
;  310			
;  311			// write out each page to flash
;  312			for(counter = 0; counter < pagemax; counter++)
.LINE 312

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_79
L_77:
;  313			{
;  314				printf("\rWriting flash page %03d/%03d", counter+1, pagemax);
.LINE 314

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__62
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%3
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,47
	PUSH	BC
	CALL	___print_uputch
	POP	BC
	LD	A,%3
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	BC,(IX+%FFFFFFF6)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
;  315				
;  316				if(counter == (pagemax - 1)) // last page to write - might need to write less than PAGESIZE
.LINE 316

	LD	IY,(IX+%FFFFFFF6)
	LEA	HL,IY+%FFFFFFFF
	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_75
;  317					fastmemcpy(addressto,addressfrom,lastpagebytes);				
.LINE 317

	LD	BC,(IX+%FFFFFFDF)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
;  318					//printf("Fake copy to %lx, from %lx, %lx bytes\r\n",addressto, addressfrom, lastpagebytes);
;  319				else 
.LINE 319

	JR	L_76
L_75:
;  320					fastmemcpy(addressto,addressfrom,PAGESIZE);
.LINE 320

	LD	BC,1024
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFED)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
L_76:
;  321					//printf("Fake copy to %lx, from %lx, %lx bytes\r\n",addressto, addressfrom, PAGESIZE);
;  322			
;  323				addressto += PAGESIZE;
.LINE 323

	LD	BC,1024
	LD	HL,(IX+%FFFFFFED)
	ADD	HL,BC
	LD	(IX+%FFFFFFED),HL
;  324				addressfrom += PAGESIZE;
.LINE 324

	LD	HL,(IX+%FFFFFFF9)
	ADD	HL,BC
	LD	(IX+%FFFFFFF9),HL
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  325			}
L_79:
.LINE 325

	LD	BC,(IX+%FFFFFFF6)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_77
;  326			lockFlashKeyRegister();	// lock the flash before WARM reset
.LINE 326

	CALL	_lockFlashKeyRegister
;  327			printf("\r\n");
.LINE 327

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__65
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  328			
;  329			//Verify correct CRC in flash
;  330			printf("Verifying flash checksum... ");
.LINE 330

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__66
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  331			crc32((char*)FLASHSTART, size);
.LINE 331

	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
;  332			crcresult = crc32_finalize();
.LINE 332

	CALL	_crc32_finalize
	LD	(IX+%FFFFFFE2),HL
	LD	(IX+%FFFFFFE5),E
;  333	
;  334			if(crcresult == crcexpected)
.LINE 334

	LD	HL,(IX+%FFFFFFE2)
	LD	E,(IX+%FFFFFFE5)
	LD	BC,(IX+%FFFFFFD5)
	LD	A,(IX+%FFFFFFD8)
	CALL	__lcmpu
	JR	NZ,L_89
;  335			{
;  336				printf("- OK\r\n");
.LINE 336

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__68
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  337				state = systemreset;
.LINE 337

	LD	BC,2
	LD	(IX+%FFFFFFF3),BC
;  338			}
;  339			else // CRC Failure - next action depends on current state
.LINE 339

	JR	L_91
L_89:
;  340			{	 // User interaction not possible without MOS handling interrupts
;  341				switch(state)
.LINE 341

	LD	HL,(IX+%FFFFFFF3)
	CALL	__case8D
	JP	(HL)
L__69:
	DW	2
	DB	0
	DW24	L_82	

	DB	1
	DW24	L_83	

	DW24	L_86	

;  342				{
;  343					case firmware:
L_82:
.LINE 343

;  344						printf("\r\nError occured during flash write\r\nRetry...\r\n");
.LINE 344

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__70
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  345						state = retry;
.LINE 345

	LD	BC,1
	LD	(IX+%FFFFFFF3),BC
;  346						break;
.LINE 346

	JR	L_91
;  347					case retry:
L_83:
.LINE 347

;  348						printf("\r\nRetry failed\r\n");
.LINE 348

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__71
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  349						while(1); // no more options unfortunately, system needs a firmware programmer
L_85:
.LINE 349

	JR	L_85
;  350					default:
L_86:
.LINE 350

;  351						state = retry;
.LINE 351

	LD	BC,1
	LD	(IX+%FFFFFFF3),BC
	JR	L_91
;  352				}
;  353			}
;  354		}		
;  355		return 0;
;  356	}
L_93:
.LINE 356

	LD	SP,IX
	POP	IX
	RET	


;**************************** _update_mos ***************************
;Name                         Addr/Register   Size   Type
;_lockFlashKeyRegister               IMPORT  -----   function
;_fastmemcpy                         IMPORT  -----   function
;__u_itoa                            IMPORT  -----   function
;___print_fmt                        IMPORT     19   variable
;_enableFlashKeyRegister             IMPORT  -----   function
;_crc32_finalize                     IMPORT  -----   function
;_crc32                              IMPORT  -----   function
;_mos_flseek                         IMPORT  -----   function
;_crc32_initialize                   IMPORT  -----   function
;_getFileSize                        IMPORT  -----   function
;_mos_fclose                         IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;_putch                              IMPORT  -----   function
;crcexpected                          IX-43      4   variable
;size                                 IX-39      3   variable
;G_0                                  IX-36      3   variable
;lastpagebytes                        IX-33      3   variable
;crcresult                            IX-30      4   variable
;value                                IX-26      1   variable
;got                                  IX-25      3   variable
;ptr                                  IX-22      3   variable
;addressto                            IX-19      3   variable
;filesize                             IX-16      3   variable
;state                                IX-13      3   variable
;pagemax                              IX-10      3   variable
;addressfrom                           IX-7      3   variable
;file                                  IX-4      1   variable
;counter                               IX-3      3   variable
;filename                              IX+6      3   parameter


; Stack Frame Size: 52 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "update_mos",356,"_update_mos"
	SEGMENT STRSECT
L__46:
	DB	"Error opening \""
	DB	0
L__47:
	DB	"\""
	DB	10,13,0
L__49:
	DB	"File does not contain valid MOS ez80 startup code"
	DB	13,10,0
L__51:
	DB	"File too large for 128KB embedded flash"
	DB	13,10,0
L__52:
	DB	13,10
	DB	"Valid ez80 code"
	DB	13,10
	DB	"Calculating CRC32"
	DB	0
L__55:
	DB	13,10,0
L__56:
	DB	"Done"
	DB	13,10,0
L__57:
	DB	"Erasing flash... "
	DB	0
L__60:
	DB	13,10
	DB	"Writing new firmware..."
	DB	13,10,0
L__62:
	DB	13
	DB	"Writing flash page "
	DB	0
L__65:
	DB	13,10,0
L__66:
	DB	"Verifying flash checksum... "
	DB	0
L__68:
	DB	"- OK"
	DB	13,10,0
L__70:
	DB	13,10
	DB	"Error occured during flash write"
	DB	13,10
	DB	"Retry..."
	DB	13,10,0
L__71:
	DB	13,10
	DB	"Retry failed"
	DB	13,10,0
	SEGMENT CODE
;  357	
;  358	void echoVDP(uint8_t value) {
_echoVDP:
.DEFINE "_echoVDP"

.VALUE _echoVDP

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "echoVDP",358,"_echoVDP"

.LINE 358

.DEFINE "value"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  359		putch(23);
.LINE 359

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  360		putch(0);
.LINE 360

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;  361		putch(0x80);
.LINE 361

	LD	BC,128
	PUSH	BC
	CALL	_putch
	POP	BC
;  362		putch(value);
.LINE 362

	LD	A,(IX+%6)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;  363		delayms(100);
.LINE 363

	LD	BC,100
	PUSH	BC
	CALL	_delayms
	POP	BC
;  364	}
.LINE 364

	LD	SP,IX
	POP	IX
	RET	


;**************************** _echoVDP ***************************
;Name                         Addr/Register   Size   Type
;_delayms                            IMPORT  -----   function
;_putch                              IMPORT  -----   function
;value                                 IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "echoVDP",364,"_echoVDP"
;  365	
;  366	int getCommand(const char *command) {
_getCommand:
.DEFINE "_getCommand"

.VALUE _getCommand

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "getCommand",366,"_getCommand"

.LINE 366

.DEFINE "command"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  367		if(memcmp(command, "all", 4) == 0) return CMDALL;
.LINE 367

	LD	BC,4
	PUSH	BC
	LD	BC,L__74
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_97
	LD	HL,1
	JR	L_101
L_97:
;  368		if(memcmp(command, "mos", 3) == 0) return CMDMOS;
.LINE 368

	LD	BC,3
	PUSH	BC
	LD	BC,L__76
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_99
	LD	HL,2
	JR	L_101
L_99:
;  369		if(memcmp(command, "vdp", 3) == 0) return CMDVDP;
.LINE 369

	LD	BC,3
	PUSH	BC
	LD	BC,L__78
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_100
	LD	HL,3
	JR	L_101
L_100:
;  370		return CMDUNKNOWN;
.LINE 370

	OR	A,A
	SBC	HL,HL
;  371	}
L_101:
.LINE 371

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getCommand ***************************
;Name                         Addr/Register   Size   Type
;_memcmp                             IMPORT  -----   function
;command                               IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getCommand",371,"_getCommand"
	SEGMENT STRSECT
L__74:
	DB	"all"
	DB	0
L__76:
	DB	"mos"
	DB	0
L__78:
	DB	"vdp"
	DB	0
	SEGMENT DATA
_flashmos:
	DB	0
.DEFINE "flashmos"
.ALIAS "_flashmos"
.CLASS 69
.VALUE _flashmos
.TYPE 12
.ENDEF
	SEGMENT BSS
_mosfilename:
	DS	256
.DEFINE "mosfilename"
.ALIAS "_mosfilename"
.CLASS 83
.VALUE _mosfilename
.DIM 256
.TYPE 98
.ENDEF
	SEGMENT DATA
_flashvdp:
	DB	0
.DEFINE "flashvdp"
.ALIAS "_flashvdp"
.CLASS 69
.VALUE _flashvdp
.TYPE 12
.ENDEF
	SEGMENT BSS
_vdpfilename:
	DS	256
.DEFINE "vdpfilename"
.ALIAS "_vdpfilename"
.CLASS 83
.VALUE _vdpfilename
.DIM 256
.TYPE 98
.ENDEF
;  372	
;  373	bool flashmos = false;
;  374	char mosfilename[256];
;  375	bool flashvdp = false;
;  376	char vdpfilename[256];
	SEGMENT CODE
;  377	
;  378	bool parseCommands(int argc, char *argv[]) {
_parseCommands:
.DEFINE "_parseCommands"

.VALUE _parseCommands

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "parseCommands",378,"_parseCommands"

.LINE 378

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

.DEFINE "argcounter"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "command"

.CLASS 65

.VALUE -15

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF1
	LD	SP,HL
;  379		int argcounter;
;  380		int command;
;  381	
;  382		argcounter = 1;
.LINE 382

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
;  383		while(argcounter < argc) {
.LINE 383

	JR	L_125
L_126:
;  384			command = getCommand(argv[argcounter]);
.LINE 384

	LD	HL,(IX+%FFFFFFFD)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_getCommand
	POP	BC
	LD	(IX+%FFFFFFF1),HL
;  385			switch(command) {
.LINE 385

	CALL	__seqcaseD
	JP	(HL)
L__81:
	DW	4
	DW	0
	DB	0
	DW24	L_102	

	DW24	L_103	

	DW24	L_107	

	DW24	L_115	

	DW24	L_124	

;  386				case CMDUNKNOWN:
L_102:
.LINE 386

;  387					return false;
.LINE 387

	XOR	A,A
	JR	L_133
;  388					break;
;  389				case CMDALL:
L_103:
.LINE 389

;  390					if(flashmos || flashvdp) return false;
.LINE 390

	LD	A,(_flashmos)
	OR	A,A
	JR	NZ,L_105
	LD	A,(_flashvdp)
	OR	A,A
	JR	Z,L_106
L_105:
	XOR	A,A
	JR	L_133
L_106:
;  391					strcpy(mosfilename, DEFAULT_MOSFIRMWARE);
.LINE 391

	LD	BC,L__84
	PUSH	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  392					strcpy(vdpfilename, DEFAULT_VDPFIRMWARE);
.LINE 392

	LD	BC,L__85
	PUSH	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  393					flashmos = true;
.LINE 393

	LD	A,%1
	LD	(_flashmos),A
;  394					flashvdp = true;
.LINE 394

	LD	(_flashvdp),A
;  395					break;
.LINE 395

	JR	L_124
;  396				case CMDMOS:
L_107:
.LINE 396

;  397					if(flashmos) return false;
.LINE 397

	LD	A,(_flashmos)
	OR	A,A
	JR	Z,L_113
	XOR	A,A
	JR	L_133
L_113:
;  398					if((argc > (argcounter+1)) && (getCommand(argv[argcounter + 1]) == CMDUNKNOWN)) {
.LINE 398

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IX+%6)
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JP	P,L_112
	LD	HL,(IX+%FFFFFFFA)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_getCommand
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_112
;  399						strcpy(mosfilename, argv[argcounter + 1]);
.LINE 399

	LD	HL,(IX+%FFFFFFFA)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  400						argcounter++;
.LINE 400

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFFD),BC
;  401					}
;  402					else {
.LINE 402

	JR	L_114
L_112:
;  403						strcpy(mosfilename, DEFAULT_MOSFIRMWARE);
.LINE 403

	LD	BC,L__89
	PUSH	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  404					}
L_114:
.LINE 404

;  405					flashmos = true;
.LINE 405

	LD	A,%1
	LD	(_flashmos),A
;  406					break;
.LINE 406

	JR	L_124
;  407				case CMDVDP:
L_115:
.LINE 407

;  408					if(flashvdp) return false;
.LINE 408

	LD	A,(_flashvdp)
	OR	A,A
	JR	Z,L_121
	XOR	A,A
	JR	L_133
L_121:
;  409					if((argc > (argcounter+1)) && (getCommand(argv[argcounter + 1]) == CMDUNKNOWN)) {
.LINE 409

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
	LD	BC,(IX+%6)
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JP	P,L_120
	LD	HL,(IX+%FFFFFFF7)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_getCommand
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_120
;  410						strcpy(vdpfilename, argv[argcounter + 1]);
.LINE 410

	LD	HL,(IX+%FFFFFFF7)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  411						argcounter++;
.LINE 411

	LD	BC,(IX+%FFFFFFF7)
	LD	(IX+%FFFFFFFD),BC
;  412					}
;  413					else {
.LINE 413

	JR	L_122
L_120:
;  414						strcpy(vdpfilename, DEFAULT_VDPFIRMWARE);
.LINE 414

	LD	BC,L__93
	PUSH	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  415					}
L_122:
.LINE 415

;  416					flashvdp = true;
.LINE 416

	LD	A,%1
	LD	(_flashvdp),A
;  417					break;
;  418			}
L_124:
.LINE 418

;  419			argcounter++;
.LINE 419

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  420		}
L_125:
.LINE 420

	LD	BC,(IX+%6)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_126
;  421		return (flashvdp || flashmos);
.LINE 421

	LD	A,(_flashvdp)
	OR	A,A
	JR	NZ,L_128
	LD	A,(_flashmos)
	OR	A,A
	JR	Z,L_129
L_128:
;  422	}
.LINE 422

	LD	BC,1
	LD	(IX+%FFFFFFF4),BC
	JR	L_130
L_129:
	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
L_130:
	LD	A,(IX+%FFFFFFF4)
L_133:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _parseCommands ***************************
;Name                         Addr/Register   Size   Type
;_vdpfilename                        STATIC    256   variable
;_mosfilename                        STATIC    256   variable
;_strcpy                             IMPORT  -----   function
;_flashvdp                           STATIC      1   variable
;_flashmos                           STATIC      1   variable
;command                              IX-15      3   variable
;temp131                              IX-12      3   variable
;G_4                                   IX-9      3   variable
;G_1                                   IX-6      3   variable
;argcounter                            IX-3      3   variable
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "parseCommands",422,"_parseCommands"
	SEGMENT STRSECT
L__84:
	DB	"MOS.bin"
	DB	0
L__85:
	DB	"firmware.bin"
	DB	0
L__89:
	DB	"MOS.bin"
	DB	0
L__93:
	DB	"firmware.bin"
	DB	0
	SEGMENT CODE
;  423	int main(int argc, char * argv[]) {	
_main:
.DEFINE "_main"

.VALUE _main

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "main",423,"_main"

.LINE 423

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

.DEFINE "sysvars"

.CLASS 65

.VALUE -3

.TAG "NONAME3"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;  424		uint8_t *gp, gpvalue;
;  425		sysvar_t *sysvars;
;  426	
;  427		if(argc == 1) {
.LINE 427

	LD	BC,1
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_136
;  428			usage();
.LINE 428

	CALL	_usage
;  429			return 0;
.LINE 429

	OR	A,A
	SBC	HL,HL
	JR	L_150
;  430		}
L_136:
.LINE 430

;  431	
;  432		if(!parseCommands(argc, argv)) {
.LINE 432

	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_parseCommands
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_137
;  433			usage();
.LINE 433

	CALL	_usage
;  434			return EXIT_INVALIDPARAMETER;
.LINE 434

	LD	HL,19
	JR	L_150
;  435		}
L_137:
.LINE 435

;  436	
;  437		printf("Result:\r\n");
.LINE 437

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__100
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  438		printf("Flash MOS: %d\r\n", flashmos);
.LINE 438

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__101
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,(_flashmos)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__102
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  439		if(flashmos) printf("filename \"%s\"\r\n", mosfilename);
.LINE 439

	LD	A,(_flashmos)
	OR	A,A
	JR	Z,L_139
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__104
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__105
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
L_139:
;  440		printf("Flash VDP: %d\r\n", flashvdp);
.LINE 440

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__106
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,(_flashvdp)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__107
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  441		if(flashvdp) printf("filename \"%s\"\r\n", vdpfilename);
.LINE 441

	LD	A,(_flashvdp)
	OR	A,A
	JR	Z,L_141
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__109
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__110
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
L_141:
;  442		return 0;
.LINE 442

	OR	A,A
	SBC	HL,HL
	JR	L_150
;  443		//
;  444	
;  445	
;  446		sysvars = getsysvars();
;  447		while(sysvars->scrheight == 0); // wait for 1st feedback from VDP
L_143:
.LINE 447

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%11)
	CALL	__scmpzero
	JR	Z,L_143
;  448		beep(1);
.LINE 448

	LD	BC,1
	PUSH	BC
	CALL	_beep
	POP	BC
;  449		sysvars->scrheight = 0;
.LINE 449

	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%11),%0
	LD	(IY+%12),%0
;  450	
;  451		update_vdp("firmware.bin");
.LINE 451

	LD	BC,L__112
	PUSH	BC
	CALL	_update_vdp
	POP	BC
;  452		echoVDP(1);
.LINE 452

	LD	BC,1
	PUSH	BC
	CALL	_echoVDP
	POP	BC
;  453		while(sysvars->scrheight == 0);
L_146:
.LINE 453

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%11)
	CALL	__scmpzero
	JR	Z,L_146
;  454		beep(2);
.LINE 454

	LD	BC,2
	PUSH	BC
	CALL	_beep
	POP	BC
;  455		update_mos("MOS.bin");
.LINE 455

	LD	BC,L__114
	PUSH	BC
	CALL	_update_mos
	POP	BC
;  456		beep(3);
.LINE 456

	LD	BC,3
	PUSH	BC
	CALL	_beep
	POP	BC
;  457		printf("Press reset button");
.LINE 457

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__115
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  458		while(1);
L_149:
.LINE 458

	JR	L_149
;  459	}
L_150:
.LINE 459

	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_vdpfilename                        STATIC    256   variable
;_flashvdp                           STATIC      1   variable
;_mosfilename                        STATIC    256   variable
;_flashmos                           STATIC      1   variable
;__u_itoa                            IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;sysvars                               IX-3      3   variable
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "main",459,"_main"
	SEGMENT STRSECT
L__100:
	DB	"Result:"
	DB	13,10,0
L__101:
	DB	"Flash MOS: "
	DB	0
L__102:
	DB	13,10,0
L__104:
	DB	"filename \""
	DB	0
L__105:
	DB	"\""
	DB	13,10,0
L__106:
	DB	"Flash VDP: "
	DB	0
L__107:
	DB	13,10,0
L__109:
	DB	"filename \""
	DB	0
L__110:
	DB	"\""
	DB	13,10,0
L__112:
	DB	"firmware.bin"
	DB	0
L__114:
	DB	"MOS.bin"
	DB	0
L__115:
	DB	"Press reset button"
	DB	0
	XREF _memcmp:ROM
	XREF _strcpy:ROM
	XREF _getFileSize:ROM
	XREF _crc32_finalize:ROM
	XREF _crc32_initialize:ROM
	XREF _crc32:ROM
	XREF _delayms:ROM
	XREF _startVDPupdate:ROM
	XREF _fastmemcpy:ROM
	XREF _lockFlashKeyRegister:ROM
	XREF _enableFlashKeyRegister:ROM
	XREF _mos_flseek:ROM
	XREF _mos_fread:ROM
	XREF _mos_fclose:ROM
	XREF _mos_fopen:ROM
	XREF _getsysvars:ROM
	XREF _getch:ROM
	XREF _tolower:ROM
	XREF __u_ultoa:ROM
	XREF __u_itoa:ROM
	XREF ___print_sendstring:ROM
	XREF ___print_xputch:ROM
	XREF ___print_uputch:ROM
	XREF ___print_fmt:ROM
	XREF __lcmpu:ROM
	XREF __iand:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __case8D:ROM
	XREF __seqcaseD:ROM
	XREF __ishru_b:ROM
	XREF __ishrs_b:ROM
	XDEF _main
	XDEF _parseCommands
	XDEF _vdpfilename
	XDEF _flashvdp
	XDEF _mosfilename
	XDEF _flashmos
	XDEF _getCommand
	XDEF _echoVDP
	XDEF _update_mos
	XDEF _update_vdp
	XDEF _getResponse
	XDEF _usage
	XDEF _print_version
	XDEF _containsESP32Header
	XDEF _esp32_magicnumbers
	XDEF _containsMosHeader
	XDEF _mos_magicnumbers
	XDEF _vdp_ota_present
	XDEF _getCharAt
	XDEF _beep
	XDEF _putch
	XDEF _errno
	END
